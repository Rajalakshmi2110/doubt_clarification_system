[
  {
    "text": "UNIT II PHYSICAL AND DATA LINK LAYERS 9 \nWired and wireless media – Functions of physical layer – Modems – Transmission errors – \nError detection and correction – Framing - Flow control – Sublayers of DLL – Broadcast \nnetworks – Collision Domain - Ethernet – CSMA/CD – Token Ring – VLAN – LAN Analyzer – \nIEEE 802.11 - WLAN – CSMA/CA – Bluetooth – Ad hoc networks. \nUnit II: Physical and Data Link Layers with a focus on Wired and Wireless Media, \nPhysical Layer, and Data Link Layer (DLL): \nWired and Wireless Media: \n• Wired Media: \no Physical cables (e.g., twisted pair, coaxial cable, fiber optics) used for data \ntransmission. \no Advantages: Higher speed, lower interference. \no Disadvantages: Limited mobility, installation cost. \n• Wireless Media: \no Uses electromagnetic waves (e.g., radio waves, microwaves) for \ncommunication. \no Advantages: Mobility, easy to install. \no Disadvantages: More prone to interference and security issues, lower \nFunctions of the Physical Layer: \n• Responsible for the transmission of raw bits over a communication medium. \n• Converts digital data into signals (electrical, optical, or radio) for transmission. \n• Ensures that signals are correctly encoded, modulated, and transmitted. \n• Handles hardware elements like cables, connectors, and signal synchronization. \n• Modulator-Demodulator: Converts digital data from a computer into analog \nsignals for transmission over analog communication lines (like phone lines) and \nvice versa. \n• Role: Enables computers to communicate over long distances using telephone \ninfrastructure. \nTransmission Errors: \n• Transmission errors occur when data is corrupted during transmission due to \nfactors like noise, attenuation, or interference. \n• Bit errors may occur when a ‘1’ is mistaken for a ‘0’ or vice versa. \nError Detection and Correction: \n• Error Detection: Methods to detect errors in transmitted data, ensuring data \no Techniques: Parity Check, Checksum, Cyclic Redundancy Check (CRC). \n• Error Correction: Methods to not only detect but also correct errors in \ntransmission. \no Techniques: Hamming Code, Reed-Solomon Codes. \nFraming (Data Link Layer): \n• Framing refers to dividing the stream of bits into smaller, manageable units called \n• Allows for synchronization between sender and receiver, and error detection can be \napplied on individual frames. \nFlow Control: \n• Mechanism to ensure that a sender doesn’t overwhelm a receiver by sending data \no Examples: Stop-and-Wait Protocol, Sliding Window Protocol. \nSublayers of Data Link Layer (DLL): \n1. Logical Link Control (LLC): Provides error checking, flow control, and manages \ndata exchange between devices. \n2. Media Access Control (MAC): Controls how devices on a network gain access to \nthe medium and permission to transmit data. It uses physical addressing (MAC \naddresses). \nBroadcast Networks: \n• Networks where data sent by one device can be received by all other devices in the \nnetwork (e.g., Ethernet LAN). \n• Broadcast networks rely on protocols like CSMA/CD to manage multiple devices \ntransmitting on the same network medium. \nCollision Domain: \n• A network segment where data packets can collide when multiple devices \ntransmit simultaneously. \n• Hubs increase the size of a collision domain, while switches segment it, reducing \ncollisions and improving efficiency. \n• A widely used wired LAN technology that uses twisted pair cables or fiber optics. \n• Operates primarily at the data link layer and the physical layer. \nCSMA/CD (Carrier Sense Multiple Access with Collision Detection): \n• A protocol used in Ethernet networks to manage access to the shared medium. \n• CSMA: Devices sense the carrier (the medium) to see if it’s free before transmitting. \n• CD: If two devices transmit simultaneously and a collision occurs, they stop, wait a \nrandom amount of time, and retransmit. \nEthernet and Related Concepts: \n• Ethernet: A widely used wired LAN technology based on the CSMA/CD protocol. \n• CSMA/CD (Carrier Sense Multiple Access with Collision Detection): A protocol \nfor managing data collisions in wired networks. Devices listen to the network before \ntransmitting and detect collisions to retransmit the data. \n• Token Ring: A LAN protocol where a token circulates in the network, and only the \ndevice holding the token can transmit data, preventing collisions. \n• VLAN (Virtual Local Area Network): Logical segmentation of a LAN into multiple, \nisolated broadcast domains, improving security and reducing broadcast traffic. \n• LAN Analyzer: A tool used to monitor, analyze, and troubleshoot LAN traffic. \nWireless Networking Concepts: \n• IEEE 802.11 WLAN: The standard for wireless LANs, commonly known as Wi-Fi. It \nprovides wireless connectivity between devices using access points. \n• CSMA/CA (Carrier Sense Multiple Access with Collision Avoidance): A protocol \nfor wireless networks where devices avoid collisions by waiting for a clear channel \nbefore transmitting. \n• Bluetooth: A short-range wireless technology used for connecting devices like \nphones, laptops, and peripherals. \n• Ad Hoc Networks: Decentralized wireless networks where devices communicate \ndirectly without relying on a fixed infrastructure (e.g., Wi-Fi Direct, Bluetooth). \n***************************************Wired Media \nWired media refers to physical cables that transmit data using electrical or optical signals. \nThey are typically used for local area networks (LANs), data centers, and various \ntelecommunications applications. \nTypes of Wired Media: \n1. Twisted Pair Cable: \na. Description: Consists of pairs of insulated copper wires twisted together to \nreduce electromagnetic interference. \nb. Categories: \ni. Cat 5e: Supports speeds up to 1 Gbps for short distances. \nii. Cat 6/6a: Supports speeds up to 10 Gbps for distances up to 55 \nmeters (Cat 6) and up to 100 meters (Cat 6a). \nc. Applications: Commonly used in Ethernet networks. \n2. Coaxial Cable: \na. Description: Composed of a central conductor, insulating layer, metallic \nshield, and outer cover. \nb. Bandwidth: Higher bandwidth capacity than twisted pair cables. \nc. Applications: Used in cable television, internet connections, and some \n3. Fiber Optic Cable: \na. Description: Composed of thin strands of glass or plastic (optical fibers) \nthat transmit data as light signals. \ni. Single-mode Fiber: Suitable for long-distance communication (up to \n40 km or more) with higher bandwidth. \nii. Multi-mode Fiber: Suitable for shorter distances (up to 2 km) and \nlower bandwidth applications. \nc. Applications: High-speed internet connections, data centers, backbone \nAdvantages of Wired Media: \n• Higher Speeds: Generally provide faster data transfer rates compared to wireless \n• Lower Latency: Less prone to delays in transmission. \n• Security: More secure than wireless as physical access to cables is required to \nintercept data. \n• Reliability: Less susceptible to interference from external factors like \nelectromagnetic interference (EMI). \nDisadvantages of Wired Media: \n• Mobility: Limited mobility; devices must be physically connected to the network. \n• Installation Costs: Can be more expensive to install due to the need for cabling \nand infrastructure. \n• Physical Limitations: Limited by distance; signal quality can degrade over long \nWireless Media \nWireless media refers to data transmission methods that use electromagnetic waves to \ntransmit data without physical cables. Wireless networks are widely used for mobile \ncommunication, internet access, and local networking. \nTypes of Wireless Media: \n1. Radio Waves: \na. Description: Use radio frequency (RF) signals to transmit data over the air. \nb. Applications: Wi-Fi networks, Bluetooth devices, and cellular networks. \n2. Microwaves: \na. Description: Higher frequency than radio waves; used for point-to-point \ncommunication. \nb. Applications: Satellite communications, microwave relay links. \n3. Infrared: \na. Description: Uses infrared light for short-range communication. \nb. Applications: Remote controls, some wireless peripherals (e.g., wireless \na. Description: Uses visible light for data transmission. \nb. Applications: Emerging technology for high-speed wireless communication \nin environments where RF communication is not feasible. \nAdvantages of Wireless Media: \n• Mobility: Allows devices to connect to the network without being physically \n• Easy Installation: Generally easier and quicker to deploy since no cabling is \n• Flexibility: Supports a range of devices, including mobile phones, tablets, and \nDisadvantages of Wireless Media: \n• Speed Limitations: Generally slower than wired media due to factors like signal \ndegradation and interference. \n• Interference: Susceptible to interference from other devices, obstacles, and \nenvironmental factors. \n• Security Risks: More vulnerable to eavesdropping and unauthorized access if not \nproperly secured. \nWired Media \nWireless Media \nTwisted pair, coaxial, fiber \nRadio waves, microwaves, infrared, Li-\nGenerally higher speeds \nGenerally lower speeds \nLower latency \nHigher latency \nLimited mobility \nHigh mobility \nInstallation More complex, higher cost \nEasier, lower cost \nReliability \nMore reliable, less \ninterference \nLess reliable, more prone to \ninterference \nMore secure \nMore vulnerable to security threats \nBoth wired and wireless media play crucial roles in modern networking. The choice \nbetween them depends on specific use cases, performance requirements, and \nenvironmental considerations. \n************************************************************************8 \nTransmission Errors in Data Communication \nTransmission errors occur when data is corrupted during the transmission process from a \nsender to a receiver. These errors can result from various factors, including: \n• Noise: Interference from electrical devices, environmental conditions, or physical \nobstructions. \n• Signal Degradation: Loss of signal strength over long distances, especially in wired \ncommunications. \n• Interference: External electromagnetic interference from other devices or \n• Packet Loss: Loss of data packets due to network congestion or faulty hardware. \nTo ensure the integrity of transmitted data, error detection and correction mechanisms are \nError Detection \n1. Parity Check \no Let's say we have a 4-bit data sequence: 1011. \no Even Parity: The number of 1's in 1011 is 3 (odd). To make it even, we add a \nparity bit of 1. The transmitted data becomes 10111. \no Receiver's Check: The receiver gets 10111, counts the number of 1's (which \nis now 4), and determines that the parity is even, so it assumes there is no \no If the received sequence is 10011 (where one bit has changed), the number \nof 1's is 3 (odd). The receiver detects a discrepancy in parity, indicating an \n2. Checksum \no Consider a data packet consisting of two 8-bit bytes: 11010101 (213 in \ndecimal) and 01100010 (98 in decimal). \no Checksum Calculation: \n▪ Add the two bytes: \n1 00110111 (Carry bit is ignored, resulting in 01101111) \n- The checksum is the one's complement of the sum:  \n- One’s complement of `01101111` is `10010000` (144 in decimal). \no Transmitted Data: The packet sent would be 11010101, 01100010, and \no Receiver's Check: \n▪ The receiver adds the two data bytes and the received checksum: \n1 00110111 (Again, ignoring the carry bit) \n- If the result is `11111111` (all bits 1), the data is considered \nvalid. If it’s anything else, an error is detected. \n3. Cyclic Redundancy Check (CRC) \no Suppose we want to send the data 1101 using a divisor polynomial 1011. \no Data: 1101 \no Append Zeros: Append n-1 zeros (where n is the degree of the divisor) to the \ndata. Thus, 1101000. \no Division: \n▪ Perform binary division of 1101000 by 1011. \n▪ The remainder is calculated as 0010. \no Transmitted Data: The transmitted message is 11010010 (original data + \no Receiver's Check: \n▪ The receiver performs the same division with the received data. If the \nremainder is 0, the data is assumed to be correct; if not, an error is \nError Correction \n1. Hamming Code \no Consider a 4-bit data sequence: 1011. \no Step 1: Determine the number of redundant bits. For 4 data bits, you need 3 \nredundant bits (r bits satisfy 2r≥m+r+12^r \\geq m + r + 12r≥m+r+1 where \nm is data bits).",
    "unit": "Unit 2",
    "source_type": "notes",
    "book_priority": 0,
    "source_file": "CN unit 2",
    "chunk_id": "CN unit 2_chunk_0"
  },
  {
    "text": "UNIT I DATA COMMUNICATION AND NETWORKING 9 \nData communication systems – Components and their functions - Building networks – \nHosts and - Networking devices – Switched Networks and Broadcast Networks – \nTransmission medium - Networking Devices: Hubs, Bridges, Switches, Routers, and \nGateways - Edge, Access and Core - networks – Role of software and hardware in \nnetworking – Layered Architecture – OSI and TCP/IP - Reference Models. \nHere’s an in-depth exploration of the key concepts in data communication systems and \nnetworking: \n1. Components of Data Communication Systems \n• Message: This is the information being transmitted between devices. It could be in \nthe form of text, audio, video, or other data types. Effective communication \ndepends on the accuracy and speed at which messages are sent and received. \n• Sender: The originator of the message, such as a computer or mobile device, that \nuses a transmission medium to send data. \n• Receiver: The destination of the message. It interprets the incoming data and \nprovides it to the end user or system application. \n• Transmission Medium: The channel through which the message is sent from \nsender to receiver. This can include: \no Wired Media: Like twisted-pair cables, coaxial cables, and fiber optic \ncables, providing high-speed, reliable connections. \no Wireless Media: Such as radio waves, microwaves, and infrared, enabling \nflexible and mobile communication. \n• Protocol: A set of standardized rules that govern the communication between \ndevices, ensuring the data is formatted, transmitted, and received correctly. \nExamples include TCP/IP, HTTP, and FTP. \n2. Building Networks \n• Networks are systems that interconnect devices to allow for the exchange of data. \nNetworks can be as small as a few devices in a room or as large as the global \n• Hosts: These are devices connected to a network, including computers, \nsmartphones, servers, and IoT devices. Hosts typically generate, receive, or \nprocess data on a network. \n• Networking Devices: Devices like routers, switches, and hubs enable data \nmovement across networks by directing traffic efficiently and maintaining \nconnectivity among hosts. \n3. Switched Networks and Broadcast Networks \n• Switched Networks: Utilize switches to route data to its intended recipient using \nMAC addresses. In switched networks, only the target device receives the data \npacket, leading to efficient use of bandwidth and enhanced privacy. \n• Broadcast Networks: Send data packets to all devices on the network segment. \nEach device checks the packet and processes it if it’s addressed to them. While \nsimple to implement, broadcast networks can be inefficient on larger scales due to \nunnecessary data processing. \n4. Transmission Medium \n• Transmission mediums serve as the conduits for data communication and can vary \nwidely depending on the network’s requirements. \n• Wired Transmission: \no Twisted Pair Cables: Common in local area networks (LANs), they consist of \npairs of wires twisted together to reduce electromagnetic interference. \no Coaxial Cables: Used for cable TV and internet, coaxial cables provide a \nshielded medium that reduces interference and supports high-frequency \no Fiber Optic Cables: Provide very high bandwidth and long-distance \ncommunication using light signals, widely used for backbone networks and \nlong-distance telecommunications. \n• Wireless Transmission: \no Radio Waves: Enable wireless communication for Wi-Fi, cellular networks, \nand Bluetooth, offering flexibility and mobility. \no Microwaves: Used for satellite communication and point-to-point links, \noffering higher bandwidth but requiring line-of-sight communication. \n5. Networking Devices \n• Hubs: Basic devices that connect multiple devices in a network but broadcast all \nincoming data to every device, creating potential congestion. \n• Bridges: Devices that connect different segments of a network, filtering traffic \nbased on MAC addresses to reduce congestion and improve network performance. \n• Switches: Advanced versions of hubs, switches use MAC addresses to direct data \npackets only to the intended device, enhancing efficiency. \n• Routers: Operate at the network layer, forwarding data between different networks \nbased on IP addresses and determining the best path for data. \n• Gateways: Connect networks using different protocols, translating data from one \nprotocol to another to enable communication across different network \narchitectures. \n6. Network Types \n• Edge Networks: These provide connectivity for end devices, often serving as the \npoint of entry to larger networks, such as internet service providers. \n• Access Networks: Typically provide local connectivity, such as a Wi-Fi network, \nallowing users to connect to other network resources and services. \n• Core Networks: Provide high-speed, reliable connections within the larger network, \noften functioning as the backbone for other network types and enabling long-\ndistance data transfer. \n7. Role of Software and Hardware in Networking \n• Hardware: The physical infrastructure required for networking, including devices \nlike routers, switches, and cables, that support data movement. \n• Software: Includes operating systems, network protocols, and applications that \ncontrol how data is formatted, transmitted, and processed, ensuring effective \ncommunication between devices. \n8. Layered Architecture – OSI and TCP/IP Models \n• OSI Model: \no A seven-layer model designed to standardize network functions. The layers \ninclude Physical, Data Link, Network, Transport, Session, Presentation, and \nApplication. \no Each layer performs specific functions, with data moving through each layer, \nundergoing transformations and encapsulations to ensure successful \n• TCP/IP Model: \no A simplified four-layer model used primarily for internet-based \ncommunications. The layers include Network Access, Internet, Transport, \nand Application. \no The TCP/IP model focuses on practical implementation, with the Application \nlayer encompassing several OSI layers. \nIn summary, data communication systems involve a complex interplay of components, \ntechnologies, and protocols that ensure data is efficiently, reliably, and securely \nexchanged across various network infrastructures. By understanding each element’s role, \nwe can build and maintain robust networks capable of supporting modern communication \n************************************************************************************* \nTransmission mediums are essential components in any data communication system, as \nthey provide the pathway for data to travel between devices. These mediums can be \nbroadly classified into two categories: wired (guided) and wireless (unguided). Each \ncategory has various types, each with unique characteristics, advantages, and limitations. \nHere’s an in-depth look at different transmission mediums, \n1. Wired Transmission Mediums (Guided Media) \nWired transmission mediums involve physical cables that guide the data signals from the \nsender to the receiver. These include: \n• Twisted Pair Cable: \no Description: This cable consists of pairs of insulated copper wires twisted \ntogether to reduce electromagnetic interference. It is widely used in local \narea networks (LANs), telephone systems, and DSL connections. \n▪ Unshielded Twisted Pair (UTP): Common in Ethernet networks; \ninexpensive and easy to install. \n▪ Shielded Twisted Pair (STP): Contains additional shielding to reduce \ninterference, offering better performance but at a higher cost. \no Advantages: Inexpensive, easy to install, and widely available. \no Limitations: Susceptible to interference and signal attenuation over long \n• Coaxial Cable: \no Description: Coaxial cables have a central conductor surrounded by \ninsulation, a metallic shield, and an outer cover. They are commonly used for \ncable television, broadband internet, and other high-frequency signal \ntransmission. \no Advantages: Higher bandwidth than twisted pair, less interference, and \nbetter signal retention over long distances. \no Limitations: Bulkier than twisted pairs, more expensive, and less flexible to \n• Fiber Optic Cable: \no Description: Fiber optic cables transmit data as pulses of light through \nstrands of glass or plastic. They are used for high-speed data transmission, \nparticularly over long distances and in backbone networks. \n▪ Single-Mode Fiber (SMF): Transmits one light signal at a time, \nsuitable for long distances and high-bandwidth applications. \n▪ Multi-Mode Fiber (MMF): Allows multiple light signals to travel \nthrough the fiber, suitable for shorter distances and lower-cost \napplications. \no Advantages: Extremely high bandwidth, low signal loss, and immune to \nelectromagnetic interference. \no Limitations: Expensive to install and maintain, requires specialized \nequipment and expertise. \n2. Wireless Transmission Mediums (Unguided Media) \nWireless transmission mediums use electromagnetic waves to transmit data without \nphysical cables, offering greater flexibility and mobility. These include: \n• Radio Waves: \no Description: Radio waves can travel long distances and penetrate through \nwalls and obstacles, making them ideal for broadcast communications (e.g., \nAM/FM radio, TV) and mobile communications (e.g., Wi-Fi, cellular \no Advantages: Wide coverage area, good penetration, and suitable for mobile \ncommunication. \no Limitations: Susceptible to interference and eavesdropping; bandwidth is \ngenerally limited compared to wired options. \n• Microwaves: \no Description: Microwaves require a direct line of sight between the \ntransmitter and receiver and are commonly used for satellite \ncommunications and point-to-point links. \n▪ Terrestrial Microwaves: Used for short-range communication \nbetween ground stations. \n▪ Satellite Microwaves: Used for long-range communication, \nbouncing signals off satellites. \no Advantages: High bandwidth, suitable for long-distance communication \nwith minimal delays. \no Limitations: Requires line of sight, affected by weather conditions, and more \nexpensive to deploy. \n• Infrared (IR): \no Description: Infrared waves are used for short-range communication, such \nas remote controls and some wireless devices. They require line of sight and \nare primarily used for indoor applications. \no Advantages: Secure over short distances, inexpensive, and not affected by \nradio interference. \no Limitations: Limited range, requires direct line of sight, and affected by \nobstructions and ambient light. \n3. Comparing Wired vs. Wireless Transmission Mediums \n• Wired Media: \no Offers higher reliability, bandwidth, and security. \no Best suited for fixed installations where high data rates are required. \n• Wireless Media: \no Provides greater flexibility and mobility. \no Suited for areas where physical cabling is impractical or costly. \no Ideal for mobile devices and applications where users need to remain \nconnected on the move. \nIn summary, choosing the right transmission medium depends on various factors such as \nthe required bandwidth, distance, cost, security, and the specific application or \nenvironment. Wired mediums are generally more reliable and suitable for high-speed, fixed \ninstallations, while wireless mediums provide flexibility and ease of access, particularly for \nmobile and temporary setups. Each medium plays a vital role in enabling efficient and \neffective data communication across different types of networks. \n****************************************************************************** \nNetworking devices are essential components in a network that facilitate communication \nbetween different devices. Key networking devices include: \na. A hub is a basic networking device that connects multiple computers in a \nb. It broadcasts data to all devices connected, regardless of the destination, \nmaking it less efficient. \nc. Works at the physical layer (Layer 1) of the OSI model. \na. A bridge connects two or more network segments and filters traffic between \nthem based on MAC addresses. \nb. It helps reduce traffic by only forwarding data to the correct destination \nc. Operates at the data link layer (Layer 2). \na. A switch is more advanced than a hub. It connects devices in a network and \ndirects data to the correct device using MAC addresses. \nb. Unlike a hub, a switch only sends data to the specific device it’s intended for, \nimproving efficiency. \nc. Also operates at the data link layer (Layer 2). \na. A router connects different networks and routes data between them. It uses \nIP addresses to determine the best path for data to travel. \nb. Operates at the network layer (Layer 3). \n5. Gateway: \na. A gateway is a device that connects two different networks, often with \ndifferent protocols. It translates data from one format to another. \nb. Works at multiple layers, typically including the application layer (Layer 7), \nbut it can involve other layers as well depending on its function. \nThese devices play distinct roles in managing data flow in a network, enhancing efficiency \nand security. \n*********************************************************************************** \nIn networking, Edge, Access, and Core refer to different layers or segments of a network \ninfrastructure, each serving specific functions: \n1. Edge Network: \na. The edge network is the outermost part of a network, where it interacts with \nexternal networks, such as the internet or other organizations' networks. \nb. Devices at the edge often include routers, firewalls, and edge switches. \nc. This layer handles external traffic and secures the internal network from \noutside threats. \n2. Access Network: \na. The access network connects end-user devices, like computers, phones, \nand IoT devices, to the network. \nb. It includes switches, wireless access points, and sometimes hubs that allow \nusers to connect to resources within the network. \nc. This is where most users interact with the network. \n3. Core Network: \na. The core network is the backbone of the entire network, providing high-speed \nand reliable data transmission between different parts of the network. \nb. It connects multiple access networks and ensures that data flows smoothly \nwithin and across the network. \nc. Core routers and switches are used in this layer for fast, efficient data \nforwarding and routing. \nThese layers work together to create a scalable, efficient, and secure network \ninfrastructure. \n**********************************************************************************88 \nLayered Architecture – OSI and TCP/IP Models \nThe OSI (Open Systems Interconnection) and TCP/IP (Transmission Control \nProtocol/Internet Protocol) models are frameworks used to understand and design \nnetwork communication. \nOSI Model (7 Layers): \nThe OSI model is a theoretical framework that standardizes networking functions into \nseven distinct layers: \n1. Physical Layer: Transmits raw bitstreams over a physical medium (e.g., cables, \nradio signals). \n2. Data Link Layer: Ensures reliable data transfer between two directly connected \nnodes; manages MAC addresses and error detection. \n3. Network Layer: Handles packet routing and forwarding across different networks \nusing IP addresses. \n4. Transport Layer: Ensures complete data transfer with error detection and \ncorrection, flow control, and retransmission (e.g., TCP, UDP). \n5. Session Layer: Manages sessions or connections between applications. \n6. Presentation Layer: Translates data formats (e.g., encryption, compression) to \nensure proper data interpretation. \n7. Application Layer: Provides network services directly to user applications (e.g., \nHTTP, FTP, SMTP). \nTCP/IP Model (4 Layers): \nThe TCP/IP model, a more practical framework, forms the basis of the internet. It has four \n1. Network Interface (Link) Layer: Combines the physical and data link layers from \nthe OSI model. It handles hardware addressing and the physical transmission of \n2. Internet Layer: Corresponds to the OSI's network layer and is responsible for \nrouting and forwarding data across networks using IP. \n3. Transport Layer: Similar to OSI's transport layer, it manages end-to-end \ncommunication and data integrity (e.g., TCP, UDP). \n4. Application Layer: Combines the OSI's session, presentation, and application \nlayers, providing application-level services like web browsing and email. \nKey Differences: \n• The OSI model is more detailed (7 layers), while the TCP/IP model is more simplified \n(4 layers). \n• The OSI model is a reference tool, while the TCP/IP model is based on actual \nprotocols used on the internet. \n*******************************************************************************88 \nBasic Understanding: \n1. What is the OSI model and why is it important in networking? \na. The OSI model is a 7-layer framework that standardizes the functions of a \nnetwork system into layers. It helps understand and troubleshoot network \noperations by breaking them into clear, functional segments. \n2. Explain the key functions of each layer in the OSI model. \na. Physical: Transmits raw bits over physical mediums. \nb. Data Link: Ensures node-to-node data transfer and error detection. \nc. Network: Handles packet routing and forwarding using IP addresses. \nd. Transport: Ensures reliable data transfer with flow control, error detection \n(e.g., TCP/UDP). \ne. Session: Manages and controls communication sessions. \nf. Presentation: Formats data, handles encryption and compression. \ng. Application: Provides network services to applications (e.g., HTTP, FTP). \n3. What is the TCP/IP model? How does it differ from the OSI model? \na. The TCP/IP model is a 4-layer framework used to describe internet \ncommunication. It combines OSI layers into broader categories and is based \non actual protocols (e.g., TCP, IP), unlike the theoretical OSI model. \n4. List the layers of the OSI and TCP/IP models and their key protocols. \na. OSI: Physical, Data Link, Network, Transport, Session, Presentation, \nApplication. \nb. TCP/IP: Link (Ethernet), Internet (IP), Transport (TCP/UDP), Application \n(HTTP, FTP). \n5. Why was the OSI model developed, and what advantages does it offer? \na. The OSI model was developed to standardize networking protocols and \nfacilitate multi-vendor equipment interoperability. It allows for easier \ntroubleshooting and modular development. \n6. Which layer of the OSI model handles routing? \na. The Network layer handles routing by determining the best path for data \npackets using IP addresses. \nComparison and Differences: \n1. Compare and contrast the OSI and TCP/IP models. \na. The OSI model has 7 layers, focusing on a clear separation of functions, \nwhile the TCP/IP model has 4 layers and is based on practical protocols used \nin internet communication. TCP/IP combines the OSI’s Presentation, \nSession, and Application layers into one Application layer. \n2. Why does the TCP/IP model have fewer layers than the OSI model? \na. The TCP/IP model is more simplified, grouping several OSI layers into \nbroader categories, reflecting practical implementations rather than \ntheoretical distinctions. \n3. What is the role of the transport layer in both the OSI and TCP/IP models? \na. In both models, the transport layer ensures end-to-end communication, \ndata integrity, error correction, and flow control using protocols like TCP and \n4. Which OSI layers are combined into a single layer in the TCP/IP model? \na. The Application, Presentation, and Session layers of the OSI model are \ncombined into the Application layer in the TCP/IP model. \n5. In which layer of the OSI model does encryption occur, and how is it handled in \nthe TCP/IP model? \na. Encryption typically occurs at the Presentation layer in the OSI model. In \nthe TCP/IP model, encryption is often implemented at the Application layer \n(e.g., HTTPS). \nFunctions and Protocols: \n1. What protocols operate at the transport layer of the TCP/IP model? \na. TCP (Transmission Control Protocol) and UDP (User Datagram Protocol) \noperate at the transport layer, providing reliable and unreliable \ncommunication, respectively. \n2. Explain the function of the data link layer and its role in error detection. \na. The data link layer ensures reliable data transfer between two directly \nconnected devices, using MAC addresses to identify devices. It also \nperforms error detection using checksums and error-correcting codes. \n3. How does the network layer in the OSI model handle packet routing? \na. The network layer uses IP addresses to determine the best route for packets \nbetween different networks. Routers handle this task, ensuring packets \nreach their destination across interconnected networks. \n4. What are the functions of the application layer in the TCP/IP model? \na. The application layer provides network services to applications. It manages \nprotocols like HTTP (for web browsing), FTP (for file transfers), and SMTP (for \nScenario-Based: \n1. In which layer would you troubleshoot network addressing issues, and why? \na. Network addressing issues are typically troubleshooted at the Network \nlayer, as it handles logical addressing using IP addresses. \n2. If two computers are unable to communicate due to differences in data \nrepresentation, which OSI layer is responsible for resolving this? \na. The Presentation layer is responsible for resolving differences in data \nformats, encryption, and compression between systems. \n3. How does the transport layer handle reliability and flow control in data \ntransmission? \na. The transport layer (specifically TCP) ensures reliability through error",
    "unit": "Unit 1",
    "source_type": "notes",
    "book_priority": 0,
    "source_file": "CNS unit 1",
    "chunk_id": "CNS unit 1_chunk_0"
  },
  {
    "text": "Topics covered\n• Data Link Layer Control Protocols\nFlow control\nError control\nFlow Control\n• ensure sending entity does not overwhelm receiving entity\n• by preventing buffer overflow\n• influenced by:\n• transmission time\n• time taken to emit all bits into medium\n• propagation time\n• time for a bit to traverse the link\n• assume here no errors but varying delays\nModel of Frame Transmission\nStop and Wait Flow Control\n• source transmits frame\n• destination receives frame and replies with \nacknowledgement (ACK)\n• source waits for ACK before sending next\n• destination can stop flow by not send ACK\n• works well for a few large frames\n• Stop and wait becomes inadequate if large block of data \nis split into small frames \nStop and Wait Link Utilization\nSliding Windows Flow Control\n• allows multiple numbered frames to be in transit\n• receiver has buffer W long\n• transmitter sends up to W frames without ACK\n• ACK includes number of next frame expected\n• sequence number is bounded by size of field (k)\n• frames are numbered modulo 2k\n• giving max window size of up to 2k - 1\n• receiver can ack frames without permitting further transmission \n(Receive Not Ready)\n• must send a normal acknowledge to resume\n• if have full-duplex link, can piggyback ACks\nSliding Window Diagram\nSliding Window Example\n2. Error Control - detection and correction of errors \n• 2 types of errors are:\n• lost frames : fails to arrive at rxr\n• damaged frames : recognizable frame arrives..but bits damaged\n• common techniques for error control are based on :\n• error detection",
    "unit": "Unit 2",
    "source_type": "notes",
    "book_priority": 0,
    "source_file": "DATA LINK CONTROL PROTOCOLS",
    "chunk_id": "DATA LINK CONTROL PROTOCOLS_chunk_0"
  },
  {
    "text": "5: DataLink Layer\nData Link Layer\nComputer Networking: \nA Top Down Approach \nFeaturing the Internet, \n2nd edition. \nJim Kurose, Keith Ross\nAddison-Wesley, July \nA note on the use of these ppt slides:\nWe’re making these slides freely available to all (faculty, students, readers). \nThey’re in PowerPoint form so you can add, modify, and delete slides  \n(including this one) and slide content to suit your needs. They obviously \nrepresent a lot of work on our part. In return for use, we only ask the \n\u0001 If you use these slides (e.g., in a class) in substantially unaltered form, \nthat you mention their source (after all, we’d like people to use our book!)\n\u0001 If you post any slides in substantially unaltered form on a www site, that \nyou note that they are adapted from (or perhaps identical to) our slides, and \nChapter 5: The Data Link Layer\n❒understand principles behind data link layer \n❍error detection, correction\n❍sharing a broadcast channel: multiple access\n❍link layer addressing\n❍reliable data transfer, flow control: done!\n❒instantiation and implementation of various link \nlayer technologies\n5: DataLink Layer\nChapter 5 outline\n❒5.1 Introduction and \n❒5.2 Error detection \nand correction \n❒5.3Multiple access \n❒5.4 LAN addresses \n❒5.5 Ethernet\n❒5.6 Hubs, bridges, and \n❒5.7 Wireless links and \n❒5.10 Frame Relay\n5: DataLink Layer\nLink Layer: Introduction\nSome terminology:\n❒hosts and routers are nodes\n(bridges and switches too)\n❒communication channels that \nconnect adjacent nodes along \ncommunication path are links\n❍wired links\n❍wireless links\n❒2-PDU is a frame,\nencapsulates datagram\ndata-link layer has responsibility of \ntransferring datagram from one node \nto adjacent node over a link\n5: DataLink Layer\nLink layer: context\n❒Datagram transferred by \ndifferent link protocols \nover different links:\n❍e.g., Ethernet on first link, \nframe relay on \nintermediate links, 802.11 \non last link\n❒Each  link protocol \nprovides different \n❍e.g., may or may not \nprovide rdt over link\ntransportation analogy\n❒trip from Princeton to \n❍limo: Princeton to JFK\n❍plane: JFK to Geneva\n❍train: Geneva to Lausanne\n❒tourist = datagram\n❒transport segment = \ncommunication link\n❒transportation mode = \nlink layer protocol\n❒travel agent = routing \n5: DataLink Layer\nLink Layer Services\n❒Framing, link access:\n❍encapsulate datagram into frame, adding header, trailer\n❍channel access if shared medium\n❍‘physical addresses’ used in frame headers to identify \nsource, dest  \n• different from IP address!\n❒Reliable delivery between adjacent nodes\n❍we learned how to do this already (chapter 3)!\n❍seldom used on low bit error link (fiber, some twisted \n❍wireless links: high error rates\n• Q: why both link-level and end-end reliability?\n5: DataLink Layer\nLink Layer Services (more)\n❒Flow Control:\n❍pacing between adjacent sending and receiving nodes\n❒Error Detection:\n❍errors caused by signal attenuation, noise. \n❍receiver detects presence of errors: \n• signals sender for retransmission or drops frame \n❒Error Correction:\n❍receiver identifies and corrects bit error(s) without \nresorting to retransmission\n❒Half-duplex and full-duplex\n❍with half duplex, nodes at both ends of link can transmit, \nbut not at same time\n5: DataLink Layer\nAdaptors Communicating\n❒link layer implemented in \n“adaptor” (aka NIC)\n❍Ethernet card, PCMCI \ncard, 802.11 card\n❒sending side:\n❍encapsulates datagram in \n❍adds error checking bits, \nrdt, flow control, etc.\n❒receiving side\n❍looks for errors, rdt, flow \ncontrol, etc\n❍extracts datagram, passes \nto rcving node\n❒adapter is semi-\n❒link & physical layers\nlink layer protocol\n5: DataLink Layer\nChapter 5 outline\n❒5.1 Introduction and \n❒5.2 Error detection \nand correction\n❒5.3Multiple access \n❒5.4 LAN addresses \n❒5.5 Ethernet\n❒5.6 Hubs, bridges, and \n❒5.7 Wireless links and \n❒5.10 Frame Relay\n5: DataLink Layer 5a-10\nError Detection\nEDC= Error Detection and Correction bits (redundancy)\nD    = Data protected by error checking, may include header fields \n• Error detection not 100% reliable!\n• protocol may miss some errors, but rarely\n• larger EDC field yields better detection and correction\n5: DataLink Layer 5a-11\nParity Checking\nSingle Bit Parity:\nDetect single bit errors\nTwo Dimensional Bit Parity:\nDetect and correct single bit errors\n5: DataLink Layer 5a-12\nInternet checksum\nChapter 5 outline\n❒5.1 Introduction and \n❒5.2 Error detection \nand correction \n❒5.3Multiple access \n❒5.4 LAN addresses \n❒5.5 Ethernet\n❒5.6 Hubs, bridges, and \n❒5.7 Wireless links and \n❒5.10 Frame Relay\n5: DataLink Layer 5a-16\nMultiple Access Links and Protocols\nTwo types of “links”:\n❒point-to-point\n❍PPP for dial-up access\n❍point-to-point link between Ethernet switch and host\n❒broadcast (shared wire or medium)\n❍traditional Ethernet\n❍upstream HFC\n❍802.11 wireless LAN\n5: DataLink Layer 5a-17\nMultiple Access protocols\n❒single shared broadcast channel \n❒two or more simultaneous transmissions by nodes: \ninterference \n❍only one node can send successfully at a time \nmultiple access protocol\n❒distributed algorithm that determines how nodes \nshare channel, i.e., determine when node can transmit\n❒communication about channel sharing must use channel \n❒what to look for in multiple access protocols: \n5: DataLink Layer 5a-18\nIdeal Mulitple Access Protocol\nBroadcast channel of rate R bps\n1. When one node wants to transmit, it can send at \n2. When M nodes want to transmit, each can send at \naverage rate R/M\n3. Fully decentralized:\n❍no special node to coordinate transmissions\n❍no synchronization of clocks, slots\n5: DataLink Layer 5a-19\nMAC Protocols: a taxonomy\nThree broad classes:\n❒Channel Partitioning\n❍divide channel into smaller “pieces” (time slots, \nfrequency, code)\n❍allocate piece to node for exclusive use\n❒Random Access\n❍channel not divided, allow collisions\n❍“recover” from collisions\n❒“Taking turns”\n❍tightly coordinate shared access to avoid collisions\n5: DataLink Layer 5a-20\nChannel Partitioning MAC protocols: TDMA\nTDMA: time division multiple access\n❒access to channel in \"rounds\" \n❒each station gets fixed length slot (length = pkt \ntrans time) in each round \n❒unused slots go idle \n❒example: 6-station LAN, 1,3,4 have pkt, slots 2,5,6 \n5: DataLink Layer 5a-21\nChannel Partitioning MAC protocols: FDMA\nFDMA: frequency division multiple access\n❒channel spectrum divided into frequency bands\n❒each station assigned fixed frequency band\n❒unused transmission time in frequency bands go idle \n❒example: 6-station LAN, 1,3,4 have pkt, frequency \nbands 2,5,6 idle \nfrequency bands\n5: DataLink Layer 5a-22\nChannel Partitioning (CDMA)\nCDMA (Code Division Multiple Access)\n❒unique “code” assigned to each user; i.e., code set partitioning\n❒used mostly in wireless broadcast channels (cellular, satellite,\n❒all users share same frequency, but each user has own \n“chipping” sequence (i.e., code) to encode data\n❒encoded signal = (original data) X (chipping sequence)\n❒decoding: inner-product of encoded signal and chipping \n❒allows multiple users to “coexist” and transmit simultaneously \nwith minimal interference (if codes are “orthogonal”)\n5: DataLink Layer 5a-23\nCDMA Encode/Decode\n5: DataLink Layer 5a-24\nCDMA: two-sender interference\n5: DataLink Layer 5a-25\nRandom Access Protocols\n❒When node has packet to send\n❍transmit at full channel data rate R.\n❍no a priori coordination among nodes\n❒two or more transmitting nodes -> “collision”,\n❒random access MAC protocol specifies: \n❍how to detect collisions\n❍how to recover from collisions (e.g., via delayed \nretransmissions)\n❒Examples of random access MAC protocols:\n❍slotted ALOHA\n❍CSMA, CSMA/CD, CSMA/CA\n5: DataLink Layer 5a-26\nSlotted ALOHA\nAssumptions\n❒all frames same size\n❒time is divided into \nequal size slots, time to \ntransmit 1 frame\n❒nodes start to transmit \nframes only at \nbeginning of slots\n❒nodes are synchronized\n❒if 2 or more nodes \ntransmit in slot, all \nnodes detect collision\n❒when node obtains fresh \nframe, it transmits in next \n❒no collision, node can send \nnew frame in next slot\n❒if collision, node \nretransmits frame in each \nsubsequent slot with prob. \np until success\n5: DataLink Layer 5a-27\nSlotted ALOHA\n❒single active node can \ncontinuously transmit \nat full rate of channel\n❒highly decentralized: \nonly slots in nodes \nneed to be in sync\n❒collisions, wasting slots\n❒idle slots\n❒nodes may be able to \ndetect collision in less \nthan time to transmit \n5: DataLink Layer 5a-28\nSlotted Aloha efficiency\n❒Suppose N nodes with \nmany frames to send, \neach transmits in slot \nwith probability p\n❒prob that 1st node has \nsuccess in a slot\n= p(1-p)N-1\n❒prob that any node has \na success = Np(1-p)N-1\n❒For max efficiency \nwith N nodes, find p* \nthat maximizes \n❒For many nodes, take \nlimit of Np*(1-p*)N-1 \nas N goes to infinity, \ngives 1/e = .37\nEfficiency is the long-run \nfraction of successful slots \nwhen there’s many nodes, each \nwith many frames to send\nAt best: channel\nused for useful \ntransmissions 37%\n5: DataLink Layer 5a-29\nPure (unslotted) ALOHA\n❒unslotted Aloha: simpler, no synchronization\n❒when frame first arrives\n❍transmit immediately \n❒collision probability increases:\n❍frame sent at t0 collides with other frames sent in [t0-1,t0+1]\n5: DataLink Layer 5a-30\nPure Aloha efficiency\nP(success by given node) = P(node transmits) .\nP(no other node transmits in [p0-1,p0] .\nP(no other node transmits in [p0-1,p0] \n= p . (1-p)N-1 . (1-p)N-1\n= p . (1-p)2(N-1)\n… choosing optimum p and then letting n -> infty ...\n= 1/(2e) = .18 \nEven worse !\n5: DataLink Layer 5a-31\nCSMA (Carrier Sense Multiple Access)\nCSMA: listen before transmit:\n❒If channel sensed idle: transmit entire frame\n❒If channel sensed busy, defer transmission \n❒Human analogy: don’t interrupt others!\n5: DataLink Layer 5a-32\nCSMA collisions\ncollisions can still occur:\npropagation delay means \ntwo nodes may not hear\neach other’s transmission\nentire packet transmission \ntime wasted\nspatial layout of nodes \nrole of distance & propagation \ndelay in determining collision \nprobability\n5: DataLink Layer 5a-33\nCSMA/CD (Collision Detection)\nCSMA/CD: carrier sensing, deferral as in CSMA\n❍collisions detected within short time\n❍colliding transmissions aborted, reducing channel \n❒collision detection:\n❍easy in wired LANs: measure signal strengths, \ncompare transmitted, received signals\n❍difficult in wireless LANs: receiver shut off while \ntransmitting\n❒human analogy: the polite conversationalist \n5: DataLink Layer 5a-34\nCSMA/CD collision detection\n5: DataLink Layer 5a-35\n“Taking Turns” MAC protocols\nchannel partitioning MAC protocols:\n❍share channel efficiently and fairly at high load\n❍inefficient at low load: delay in channel access, \n1/N bandwidth allocated even if only 1 active \nRandom access MAC protocols\n❍efficient at low load: single node can fully \nutilize channel\n❍high load: collision overhead\n“taking turns” protocols\nlook for best of both worlds!\n5: DataLink Layer 5a-36\n“Taking Turns” MAC protocols\n❒master node \n“invites” slave nodes \nto transmit in turn\n❍polling overhead \n❍single point of \nfailure (master)\nToken passing:\n❒control token passed from \none node to next \nsequentially.\n❒token message\n❍token overhead \n❍single point of failure (token)\n5: DataLink Layer 5a-37\nSummary of MAC protocols\n❒What do you do with a shared media?\n❍Channel Partitioning, by time, frequency or code\n• Time Division,Code Division, Frequency Division\n❍Random partitioning (dynamic), \n• ALOHA, S-ALOHA, CSMA, CSMA/CD\n• carrier sensing: easy in some technologies (wire), hard \nin others (wireless)\n• CSMA/CD used in Ethernet\n❍Taking Turns\n• polling from a central site, token passing\n5: DataLink Layer 5a-38\nLAN technologies\nData link layer so far:\n❍services, error detection/correction, multiple \nNext: LAN technologies\n❍addressing\n❍hubs, bridges, switches\n5: DataLink Layer 5a-39\nLAN Addresses and ARP\n32-bit IP address:\n❒network-layer address\n❒used to get datagram to destination IP network \n(recall IP network definition)\nLAN (or MAC or physical or Ethernet) address: \n❒used to get datagram from one interface to another \nphysically-connected interface (same network)\n❒48 bit MAC address (for most LANs) \nburned in the adapter ROM\n5: DataLink Layer 5a-40\nLAN Addresses and ARP\nEach adapter on LAN has unique LAN address\n5: DataLink Layer 5a-41\nLAN Address (more)\n❒MAC address allocation administered by IEEE\n❒manufacturer buys portion of MAC address space \n(to assure uniqueness)\n(a) MAC address: like Social Security Number\n(b) IP address: like postal address\n❒MAC flat address  => portability \n❍can move LAN card from one LAN to another\n❒IP hierarchical address NOT portable\n❍depends on IP network to which node is attached\n5: DataLink Layer 5a-42\nRecall earlier routing discussion\nStarting at A, given IP \ndatagram addressed to B:\n❒look up net. address of B, find B \non same net. as A\n❒link layer send datagram to B \ninside link-layer frame\nframe source,\ndest address\ndatagram source,\ndest address\n5: DataLink Layer 5a-43\nARP: Address Resolution Protocol\n❒Each IP node (Host, \nRouter) on LAN has  \n❒ARP Table: IP/MAC \naddress mappings for \nsome LAN nodes\n< IP address; MAC address; TTL>\nTTL (Time To Live): time \nafter which address \nmapping will be forgotten \n(typically 20 min)\nQuestion: how to determine\nMAC address of B\nknowing B’s IP address?\n5: DataLink Layer 5a-44\nARP protocol\n❒A wants to send datagram \nto B, and A knows B’s IP \n❒Suppose B’s MAC address \nis not in A’s ARP table.\n❒A broadcasts ARP query \npacket, containing B's IP \n❍all machines on LAN \nreceive ARP query\n❒B receives ARP packet, \nreplies to A with its (B's) \nMAC address\n❍frame sent to A’s MAC \naddress (unicast)\n❒A caches (saves) IP-to-\nMAC address pair in its \nARP table until information \nbecomes old (times out) \n❍soft state: information \nthat times out (goes \naway) unless refreshed\n❒ARP is “plug-and-play”:\n❍nodes create their ARP \ntables without \nintervention from net \nadministrator\n5: DataLink Layer 5a-45\nRouting to another LAN\nwalkthrough: send datagram from A to B via R\nassume  A knows B IP address\n❒Two ARP tables in  router R, one for each IP \nnetwork (LAN)\n5: DataLink Layer 5a-46\n❒A creates datagram with source A, destination B \n❒A uses ARP to get R’s MAC address for 111.111.111.110\n❒A creates link-layer frame with R's MAC address as dest, \nframe contains A-to-B IP datagram\n❒A’s data link layer sends frame \n❒R’s data link layer receives frame \n❒R removes IP datagram from Ethernet frame, sees its \ndestined to B\n❒R uses ARP to get B’s physical layer address \n❒R creates frame containing A-to-B IP datagram sends to B\n5: DataLink Layer 5a-47\n“dominant” LAN technology: \n❒cheap $20 for 100Mbs!\n❒first widely used LAN technology\n❒Simpler, cheaper than token LANs and ATM\n❒Kept up with speed race: 10, 100, 1000 Mbps \nMetcalfe’s Ethernet\n5: DataLink Layer 5a-48\nEthernet Frame Structure\nSending adapter encapsulates IP datagram (or other \nnetwork layer protocol packet) in Ethernet frame\n❒7 bytes with pattern 10101010 followed by one \nbyte with pattern 10101011\n❒used to synchronize receiver, sender clock rates\n5: DataLink Layer 5a-49\nEthernet Frame Structure \n❒Addresses: 6 bytes\n❍if adapter receives frame with matching destination \naddress, or with broadcast address (eg ARP packet), it \npasses data in frame to net-layer protocol\n❍otherwise, adapter discards frame\n❒Type: indicates the higher layer protocol, mostly \nIP but others may be supported such as Novell \nIPX and AppleTalk)\n❒CRC: checked at receiver, if error is detected, the \nframe is simply dropped\n5: DataLink Layer 5a-50\nUnreliable, connectionless service\n❒Connectionless: No handshaking between sending \nand receiving adapter. \n❒Unreliable: receiving adapter doesn’t send acks or \nnacks to sending adapter\n❍stream of datagrams passed to network layer can have \n❍gaps will be filled if app is using TCP\n❍otherwise, app will see the gaps\n5: DataLink Layer 5a-51\nEthernet uses CSMA/CD\n❒adapter doesn’t transmit \nif it senses that some \nother adapter is \ntransmitting, that is, \ncarrier sense\n❒transmitting adapter \naborts when it senses \nthat another adapter is \ntransmitting, that is, \ncollision detection\n❒Before attempting a \nretransmission, \nadapter waits a \nrandom time, that is, \nrandom access\n5: DataLink Layer 5a-52\nEthernet CSMA/CD algorithm\n1. Adaptor gets datagram \nfrom and creates frame\n2. If adapter senses channel \nidle, it starts to transmit \nframe. If it senses \nchannel busy, waits until \nchannel idle and then \n3. If adapter transmits \nentire frame without \ndetecting another \ntransmission, the adapter \nis done with frame !\n4. If adapter detects \nanother transmission while \ntransmitting,  aborts and \nsends jam signal\n5. After aborting, adapter \nenters exponential \nbackoff: after the mth\ncollision, adapter chooses \na K at random from \n{0,1,2,…,2m-1}. Adapter \nwaits K*512 bit times and \nreturns to Step 2\n5: DataLink Layer 5a-53\nEthernet’s CSMA/CD (more)\nJam Signal: make sure all \nother transmitters are \naware of collision; 48 bits;\nBit time: .1 microsec for 10 \nMbps Ethernet ;\nfor K=1023, wait time is \nabout 50 msec\nExponential Backoff:\n❒Goal: adapt retransmission \nattempts to estimated \ncurrent load\n❍heavy load: random wait \nwill be longer\n❒first collision: choose K \nfrom {0,1}; delay is K x 512 \nbit transmission times\n❒after second collision: \nchoose K from {0,1,2,3}…\n❒after ten collisions, choose \nK from {0,1,2,3,4,…,1023}\nSee/interact with Java\napplet on AWL Web site:\nhighly recommended !\n5: DataLink Layer 5a-54\nCSMA/CD efficiency\n❒Tprop = max prop between 2 nodes in LAN\n❒ttrans = time to transmit max-size frame\n❒Efficiency goes to 1 as tprop goes to 0\n❒Goes to 1 as ttrans goes to infinity\n❒Much better than ALOHA, but still decentralized, \nsimple, and cheap\n5: DataLink Layer 5a-55\nEthernet Technologies: 10Base2\n❒10: 10Mbps; 2: under 200 meters max  cable length\n❒thin coaxial cable in a bus topology\n❒repeaters used to connect up to multiple segments\n❒repeater repeats bits it hears on one interface to \nits other interfaces: physical layer device only!\n❒has become a legacy technology\n5: DataLink Layer 5a-56\n10BaseT and 100BaseT\n❒10/100 Mbps rate; latter called “fast ethernet”\n❒T stands for Twisted Pair\n❒Nodes connect to a hub: “star topology”; 100 m \nmax distance between nodes and hub\n❒Hubs are essentially physical-layer repeaters:\n❍bits coming in one link go out all other links\n❍no frame buffering\n❍no CSMA/CD at hub: adapters detect collisions\n❍provides net management functionality\n5: DataLink Layer 5a-57\nManchester encoding\n❒Used in 10BaseT, 10Base2\n❒Each bit has a transition\n❒Allows clocks in sending and receiving nodes to \nsynchronize to each other\n❍no need for a centralized, global clock among nodes!\n❒Hey, this is physical-layer stuff!\n5: DataLink Layer 5a-58\nGbit Ethernet\n❒use standard Ethernet frame format\n❒allows for point-to-point links and shared \nbroadcast channels\n❒in shared mode, CSMA/CD is used; short distances \nbetween nodes to be efficient\n❒uses hubs, called here “Buffered Distributors”\n❒Full-Duplex at 1 Gbps for point-to-point links\n❒10 Gbps now !\n5: DataLink Layer 5a-59\nChapter 5 outline\n❒5.1 Introduction and \n❒5.2 Error detection \nand correction \n❒5.3Multiple access \n❒5.4 LAN addresses \n❒5.5 Ethernet\n❒5.6 Hubs, bridges, and \n❒5.7 Wireless links and \n❒5.10 Frame Relay\n5: DataLink Layer 5a-60\nInterconnecting LAN segments\n❍Remark: switches are essentially multi-port \n❍What we say about bridges also holds for \n5: DataLink Layer 5a-61\nInterconnecting with hubs\n❒Backbone hub interconnects LAN segments\n❒Extends max distance between nodes\n❒But individual segment collision domains become one \nlarge collision domain\n❍if a node in CS and a node EE transmit at same time: collision\n❒Can’t interconnect 10BaseT & 100BaseT\n5: DataLink Layer 5a-62\n❒Link layer device\n❍stores and forwards Ethernet frames\n❍examines frame header and selectively\nforwards  frame based on MAC dest address\n❍when frame is to be forwarded on segment, \nuses CSMA/CD to access segment\n❒transparent\n❍hosts are unaware of presence of bridges\n❒plug-and-play, self-learning\n❍bridges do not need to be configured\n5: DataLink Layer 5a-63\nBridges: traffic isolation\n❒Bridge installation breaks LAN into LAN segments\n❒bridges filter packets:\n❍same-LAN-segment frames not usually \nforwarded onto other LAN segments\n❍segments become separate collision  domains\nLAN (IP network)\nLAN segment\nLAN segment\n5: DataLink Layer 5a-64\nHow do determine to which LAN segment to \nforward frame?\n• Looks like a routing problem...\n5: DataLink Layer 5a-65\nSelf learning\n❒A bridge has a bridge table\n❒entry in bridge table: \n❍(Node LAN Address, Bridge Interface, Time Stamp)\n❍stale entries in table dropped (TTL can be 60 min) \n❒bridges learn which hosts can be reached through \nwhich interfaces\n❍when frame received, bridge “learns”  location of \nsender: incoming LAN segment\n❍records sender/location pair in bridge table\n5: DataLink Layer 5a-66\nFiltering/Forwarding\nWhen bridge receives a frame:\nChapter 5 outline\n❒5.1 Introduction and \n❒5.2 Error detection \nand correction \n❒5.3Multiple access \n❒5.4 LAN addresses \n❒5.5 Ethernet\n❒5.6 Hubs, bridges, and \n❒5.7 Wireless links and \n❒5.10 Frame Relay\n5: DataLink Layer 5a-81\nIEEE 802.11 Wireless LAN\n❍2.4-5 GHz unlicensed \nradio spectrum\n❍up to 11 Mbps\n❍direct sequence spread \nspectrum (DSSS) in \nphysical layer\n• all hosts use same \nchipping code\n❍widely deployed, using \nbase stations\n❍5-6 GHz range\n❍up to 54 Mbps\n❍2.4-5 GHz range\n❍up to 54 Mbps\n❒All use CSMA/CA for \nmultiple access\n❒All have base-station \nand ad-hoc network \n5: DataLink Layer 5a-82\nBase station approach\n❒Wireless host communicates with a base station\n❍base station = access point (AP)\n❒Basic Service Set (BSS) (a.k.a. “cell”) contains:\n❍wireless hosts\n❍access point (AP): base station\n❒BSSs combined to form distribution system (DS)\n5: DataLink Layer 5a-83\nAd Hoc Network approach\n❒No AP (i.e., base station)\n❒wireless hosts communicate with each other\n❍to get packet from wireless host A to B may \nneed to route through wireless hosts X,Y,Z\n❒Applications:\n❍“laptop” meeting in conference room, car\n❍interconnection of “personal” devices\n❍battlefield \n❒IETF MANET \n(Mobile Ad hoc Networks) \nworking group \n5: DataLink Layer 5a-84\nIEEE 802.11: multiple access\n❒Collision if 2 or more nodes transmit at same time\n❒CSMA makes sense:\n❍get all the bandwidth if you’re the only one transmitting\n❍shouldn’t cause a collision if you sense another transmission\n❒Collision detection doesn’t work: hidden terminal \n5: DataLink Layer 5a-85\nIEEE 802.11 MAC Protocol: CSMA/CA\n802.11 CSMA: sender\n- if sense channel idle for \nthen transmit entire frame \n(no collision detection)\n-if sense channel busy \nthen binary backoff\n802.11 CSMA receiver\n- if received OK\nreturn ACK after SIFS\n(ACK is needed due to \nhidden terminal problem) \n5: DataLink Layer 5a-86\nCollision avoidance mechanisms\n❍two nodes, hidden from each other, transmit complete \nframes to base station\n❍wasted bandwidth for long duration !\n❍small reservation packets\n❍nodes track reservation interval  with internal \n“network allocation vector” (NAV)\n5: DataLink Layer 5a-87\nCollision Avoidance: RTS-CTS \n❒sender transmits short \nRTS (request to send) \npacket: indicates \nduration of transmission\n❒receiver replies with \nshort CTS (clear to send) \n❍notifying (possibly hidden) \n❒hidden nodes will  not \ntransmit for specified \nduration: NAV\n5: DataLink Layer 5a-88\nCollision Avoidance: RTS-CTS \n❒RTS and CTS short:\n❍collisions less likely, of \nshorter duration\n❍end result similar to \ncollision detection\n❒IEEE 802.11 allows:\n❍CSMA/CA: reservations\n❍polling from AP\n5: DataLink Layer 5a-89\nA word about Bluetooth\n❒Low-power, small radius, \nwireless networking \n❍10-100 meters\n❒omnidirectional\n❍not line-of-sight infrared\n❒Interconnects gadgets\n❒2.4-2.5 GHz unlicensed \n❒up to 721 kbps\n❒Interference from \nwireless LANs, digital \ncordless phones, \nmicrowave ovens:\n❍frequency hopping helps\n❒MAC protocol supports:\n❍error correction\n❒Each node has a 12-bit \n5: DataLink Layer 5a-90\nChapter 5 outline\n❒5.1 Introduction and \n❒5.2 Error detection \nand correction \n❒5.3Multiple access \n❒5.4 LAN addresses \n❒5.5 Ethernet\n❒5.6 Hubs, bridges, and \n❒5.7 Wireless links and \n❒5.10 Frame Relay\n5: DataLink Layer 5a-91\nPoint to Point Data Link Control\n❒one sender, one receiver, one link: easier than \nbroadcast link:\n❍no Media Access Control\n❍no need for explicit MAC addressing\n❍e.g., dialup link, ISDN line\n❒popular  point-to-point DLC protocols:\n❍PPP (point-to-point protocol)\n❍HDLC: High level data link control (Data link \nused to be considered “high layer” in protocol \n5: DataLink Layer 5a-92\nPPP Design Requirements [RFC 1557]\n❒packet framing: encapsulation of network-layer \ndatagram in data link frame \n❍carry network layer data of any network layer \nprotocol (not just IP) at same time\n❍ability to demultiplex upwards\n❒bit transparency: must carry any bit pattern in the \n❒error detection (no correction)\n❒connection liveness: detect, signal link failure to \nnetwork layer\n❒network layer address negotiation: endpoint can \nlearn/configure each other’s network address\n5: DataLink Layer 5a-93\nPPP non-requirements\n❒no error correction/recovery\n❒no flow control\n❒out of order delivery OK \n❒no need to support multipoint links (e.g., polling)\nError recovery, flow control, data re-ordering \nall relegated to higher layers!\n5: DataLink Layer 5a-94\nPPP Data Frame\n❒Flag: delimiter (framing)\n❒Address: does nothing (only one option)\n❒Control: does nothing; in the future possible \nmultiple control fields\n❒Protocol: upper layer protocol to which frame \ndelivered (eg, PPP-LCP, IP, IPCP, etc) \n5: DataLink Layer 5a-95\nPPP Data Frame\n❒info: upper layer data being carried\n❒check: cyclic redundancy check for error \n5: DataLink Layer 5a-96\nByte Stuffing\n❒“data transparency” requirement: data field must \nbe allowed to include flag pattern  <01111110>\n❍Q: is received <01111110> data or flag?\n❒Sender: adds (“stuffs”) extra < 01111110> byte \nafter each < 01111110> data  byte\n❍two 01111110 bytes in a row: discard first byte, \ncontinue data reception\n❍single 01111110: flag byte\n5: DataLink Layer 5a-97\nByte Stuffing\nflag byte pattern plus\nstuffed byte in \ntransmitted  data\n5: DataLink Layer 5a-98\nPPP Data Control Protocol\nBefore exchanging network-\nlayer data, data link peers \n❒configure PPP link (max. \nframe length, \nauthentication)\n❒learn/configure network\nlayer information\n❍for IP: carry IP Control \nProtocol (IPCP) msgs\n(protocol field: 8021) to \nconfigure/learn IP \n5: DataLink Layer 5a-99\nChapter 5 outline\n❒5.1 Introduction and \n❒5.2 Error detection \nand correction \n❒5.3Multiple access \n❒5.4 LAN addresses \n❒5.5 Ethernet\n❒5.6 Hubs, bridges, and \n❒5.7 Wireless links and \n❒5.10 Frame Relay\n5: DataLink Layer\nAsynchronous Transfer Mode: ATM\n❒1990’s/00 standard for high-speed (155Mbps to \n622 Mbps and higher) Broadband Integrated \nService Digital Network architecture\n❒Goal: integrated, end-end transport of carry voice, \nvideo, data\n❍meeting timing/QoS requirements of voice, video \n(versus Internet best-effort model)\n❍“next generation” telephony: technical roots in \ntelephone world\n❍packet-switching (fixed length packets, called \n“cells”) using virtual circuits\n5: DataLink Layer\nATM architecture \n❒adaptation layer: only at edge of ATM network\n❍data segmentation/reassembly\n❍roughly analogous to Internet transport layer\n❒ATM layer: “network” layer\n❍cell switching, routing\n❒physical layer\n5: DataLink Layer\nATM:  network or link layer?\nVision: end-to-end \ntransport: “ATM from \ndesktop to desktop”\n❍ATM is a network \nReality: used to connect \nIP backbone routers  \n❍“IP over ATM”\n❍ATM as switched \nlink layer, \nconnecting IP \n5: DataLink Layer\nATM Adaptation Layer (AAL)\n❒ATM Adaptation Layer (AAL): “adapts” upper \nlayers (IP or native ATM applications)  to ATM \nlayer below\n❒AAL present only in end systems, not in switches\n❒AAL layer segment (header/trailer fields, data) \nfragmented across multiple ATM cells \n❍analogy: TCP segment in many IP packets\n5: DataLink Layer\nATM Adaptation Layer (AAL) [more]\nDifferent versions of AAL layers, depending on ATM \nservice class:\n❒AAL1: for CBR (Constant Bit Rate) services, e.g. circuit emulation\n❒AAL2: for VBR (Variable Bit Rate) services, e.g., MPEG video\n❒AAL5: for data (e.g., IP datagrams)\n5: DataLink Layer\nAAL5 - Simple And Efficient \n❒AAL5: low overhead AAL used to carry IP \n❍4 byte cyclic redundancy check \n❍PAD ensures payload multiple of 48bytes \n❍large AAL5 data unit to be fragmented into 48-\nbyte ATM cells\n5: DataLink Layer\nService: transport cells across ATM network\n❒analogous to IP network layer\n❒very different services than IP network layer\nArchitecture\nbest effort\nno (inferred\nGuarantees ?\n5: DataLink Layer\nATM Layer: Virtual Circuits\n❒VC transport: cells carried on VC from source to dest\n❍call setup, teardown for each call before data can flow\n❍each packet carries VC identifier (not destination ID)\n❍every switch on source-dest path maintain “state” for each \npassing connection\n❍link,switch resources (bandwidth, buffers) may be allocated to \nVC: to get circuit-like perf.\n❒Permanent VCs (PVCs)\n❍long lasting connections\n❍typically: “permanent” route between to IP routers\n❒Switched VCs (SVC):\n❍dynamically set up on per-call basis\n5: DataLink Layer\n❒Advantages of ATM VC approach:\n❍QoS performance guarantee for connection \nmapped to VC (bandwidth, delay, delay jitter)\n❒Drawbacks of ATM VC approach:\n❍Inefficient support of datagram traffic\n❍one PVC between each source/dest pair) does \nnot scale (N*2 connections needed) \n❍SVC introduces call setup latency, processing \noverhead for short lived connections\n5: DataLink Layer\nATM Layer: ATM cell\n❒5-byte ATM cell header\n❒48-byte payload\n❍Why?: small payload -> short cell-creation delay \nfor digitized voice\n❍halfway between 32 and 64 (compromise!)\nCell header\nCell format\n5: DataLink Layer\nATM cell header\n❒VCI: virtual channel ID\n❍will change from link to link thru net\n❒PT: Payload type (e.g. RM cell versus data cell) \n❒CLP: Cell Loss Priority bit\n❍CLP = 1 implies low priority cell, can be \ndiscarded if congestion\n❒HEC: Header Error Checksum\n❍cyclic redundancy check\n5: DataLink Layer\nATM Physical Layer (more)\nTwo pieces (sublayers) of physical layer:\n❒Transmission Convergence Sublayer (TCS): adapts \nATM layer above to PMD sublayer below\n❒Physical Medium Dependent: depends on physical \nmedium being used\nTCS Functions:\n❍Header checksum generation: 8 bits CRC \n❍Cell delineation\n❍With “unstructured” PMD sublayer, transmission \nof idle cells when no data cells to send\n5: DataLink Layer\nATM Physical Layer\nPhysical Medium Dependent (PMD) sublayer\n❒SONET/SDH: transmission frame structure (like a \ncontainer carrying bits); \n❍bit synchronization; \n❍bandwidth partitions (TDM); \n❍several speeds: OC3 = 155.52 Mbps; OC12 = 622.08 \nMbps; OC48 = 2.45 Gbps, OC192 = 9.6 Gbps\n❒TI/T3: transmission frame structure (old \ntelephone hierarchy): 1.5 Mbps/ 45 Mbps\n❒unstructured: just cells (busy/idle)\n5: DataLink Layer\nIP-Over-ATM\nClassic IP only\n❒3 “networks” (e.g., \nLAN segments)\n❒MAC (802.3) and IP \nIP over ATM\n❒replace “network” \n(e.g., LAN segment) \nwith ATM network\n❒ATM addresses, IP \n5: DataLink Layer\nIP-Over-ATM\n❒IP datagrams into \nATM AAL5 PDUs\n❒from IP addresses \nto ATM addresses\n❍just like IP \naddresses to \n5: DataLink Layer\nDatagram Journey in IP-over-ATM Network\n❒at Source Host:\n❍IP layer maps between IP, ATM dest address (using ARP)\n❍passes datagram to AAL5\n❍AAL5 encapsulates data, segments cells, passes to ATM layer \n❒ATM network: moves cell along VC to destination\n❒at Destination Host:\n❍AAL5  reassembles cells into original datagram\n❍if CRC OK, datagram is passed to IP\n5: DataLink Layer\nChapter 5 outline\n❒5.1 Introduction and \n❒5.2 Error detection \nand correction \n❒5.3Multiple access \n❒5.4 LAN addresses \n❒5.5 Ethernet\n❒5.6 Hubs, bridges, and \n❒5.7 Wireless links and \n❒5.10 Frame Relay\n5: DataLink Layer\nFrame Relay\n❒wide area network technologies \n❒Virtual-circuit oriented \n❒origins in telephony world\n❒can be used to carry IP datagrams\n❍can thus be viewed as link layers by IP \n5: DataLink Layer\nFrame Relay\n❒Designed in late ‘80s, widely deployed in the ‘90s\n❒Frame relay service:\n❍no error control\n❍end-to-end congestion control\n5: DataLink Layer\nFrame Relay (more)\n❒Designed to interconnect corporate customer LANs\n❍typically permanent VC’s: “pipe” carrying aggregate \ntraffic between two routers \n❍switched VC’s: as in ATM\n❒corporate customer leases FR service from public \nFrame Relay network (e.g., Sprint, ATT)\n5: DataLink Layer\nFrame Relay (more)\n❒Flag bits, 01111110, delimit frame\n❍10 bit VC ID field\n❍3 congestion control bits\n• FECN: forward explicit congestion \nnotification (frame experienced congestion \n• BECN: congestion on reverse path\n• DE: discard eligibility\n5: DataLink Layer\nFrame Relay -VC Rate Control\n❒Committed Information Rate (CIR)\n❍defined, “guaranteed” for each VC\n❍negotiated at VC set up time\n❍customer pays based on CIR\n❒DE bit: Discard Eligibility bit\n❍Edge FR switch measures traffic rate for each VC; \nmarks DE bit\n❍DE = 0: high priority, rate compliant frame; deliver \nat “all costs”\n❍DE = 1: low priority, eligible for congestion discard\n5: DataLink Layer\nFrame Relay - CIR & Frame Marking\n❒Access Rate: rate R of the access link between \nsource router (customer) and edge FR switch\n(provider); 64Kbps < R < 1,544Kbps\n❒Typically, many VCs (one per destination router) \nmultiplexed on the same access trunk; each VC has \n❒Edge FR switch measures traffic rate for each \nVC; it marks (i.e. DE = 1) frames which exceed CIR \n(these may be later dropped)\n❒Internet’s more recent differentiated service\nuses similar ideas\n5: DataLink Layer\nChapter 5: Summary\n❒principles behind data link layer services:\n❍error detection, correction\n❍sharing a broadcast channel: multiple access\n❍link layer addressing, ARP\n❒link layer technologies: Ethernet, hubs, \nbridges, switches,IEEE 802.11 LANs, PPP, \nATM, Frame Relay\n❒journey down the protocol stack now OVER!\n❍next stops: multimedia, security, network",
    "unit": "Unit 2",
    "source_type": "notes",
    "book_priority": 0,
    "source_file": "Data Link Layer",
    "chunk_id": "Data Link Layer_chunk_0"
  },
  {
    "text": "Network Layer \nNetworking: A Top \nDown Approach  \n6th edition  \nJim Kurose, Keith Ross \nAddison-Wesley \nA note on the use of these ppt slides: \nWe’re making these slides freely available to all (faculty, students, readers). \nThey’re in PowerPoint form so you see the animations; and can add, modify, \nand delete slides  (including this one) and slide content to suit your needs. \nThey obviously represent a lot of work on our part. In return for use, we only \nask the following: \nv  If you use these slides (e.g., in a class) that you mention their source \n(after all, we’d like people to use our book!) \nv  If you post any slides on a www site, that you note that they are adapted \nChapter 4: network layer \nchapter goals:  \nv  understand principles behind network layer \n§  network layer service models \n§  forwarding versus routing \n§  how a router works \n§  routing (path selection) \n§  broadcast, multicast \nv  instantiation, implementation in the Internet \nNetwork Layer 4-3 \n4.1 introduction \n4.2 virtual circuit and \ndatagram networks \n4.3 what’s inside a router \n4.4 IP: Internet Protocol \n§  datagram format \n§  IPv4 addressing \n4.5 routing algorithms \n§  link state \n§  distance vector \n§  hierarchical routing \n4.6 routing in the Internet \n4.7 broadcast and multicast \nChapter 4: outline \nNetwork Layer 4-4 \nNetwork layer \nv  transport segment from \nsending to receiving host  \nv  on sending side \nencapsulates segments \ninto datagrams \nv  on receiving side, delivers \nsegments to transport \nv  network layer protocols \nin every host, router \nv  router examines header \nfields in all IP datagrams \npassing through it \napplication \napplication \nNetwork Layer 4-5 \nTwo key network-layer functions \nv  forwarding: move packets \nfrom router’s input to \nappropriate router \nv  routing: determine route \ntaken by packets from \nsource to dest.  \n§  routing algorithms \nv  routing: process of \nplanning trip from source \nv  forwarding: process of \ngetting through single \ninterchange \nNetwork Layer 4-6 \nvalue in arriving \npacket’s header \nrouting algorithm \nlocal forwarding table \nheader value output link \nInterplay between routing and forwarding \nrouting algorithm determines \nend-end-path through network \nforwarding table determines \nlocal forwarding at this router \nNetwork Layer 4-7 \nConnection setup \nv  3rd important function in some network \narchitectures: \n§  ATM, frame relay, X.25 \nv  before datagrams flow, two end hosts and \nintervening routers establish virtual connection \n§  routers get involved \nv  network vs transport layer connection service: \n§  network: between two hosts (may also involve intervening \nrouters in case of VCs) \n§  transport: between two processes \nNetwork Layer 4-8 \nNetwork service model \nQ: What service model for “channel” transporting \ndatagrams from sender to receiver? \nexample services for \nindividual datagrams: \nv  guaranteed delivery \nv  guaranteed delivery with \nless than 40 msec delay \nexample services for a flow \nof datagrams: \nv  in-order datagram \nv  guaranteed minimum \nbandwidth to flow \nv  restrictions on changes in \ninter-packet spacing \nNetwork Layer 4-9 \nNetwork layer service models: \nArchitecture \nbest effort \nno (inferred \nGuarantees ? \nNetwork Layer 4-10 \n4.1 introduction \n4.2 virtual circuit and \ndatagram networks \n4.3 what’s inside a router \n4.4 IP: Internet Protocol \n§  datagram format \n§  IPv4 addressing \n4.5 routing algorithms \n§  link state \n§  distance vector \n§  hierarchical routing \n4.6 routing in the Internet \n4.7 broadcast and multicast \nChapter 4: outline \nNetwork Layer 4-11 \nConnection, connection-less service \nv  datagram network provides network-layer \nconnectionless service \nv  virtual-circuit network provides network-layer \nconnection service \nv  analogous to TCP/UDP connecton-oriented / \nconnectionless transport-layer services, but: \n§  service: host-to-host \n§  no choice: network provides one or the other \n§  implementation: in network core \nNetwork Layer 4-12 \nVirtual circuits \nv  call setup, teardown for each call before data can flow \nv  each packet carries VC identifier (not destination host \nv  every router on source-dest path maintains “state” for \neach passing connection \nv  link, router resources (bandwidth, buffers) may be \nallocated to VC (dedicated resources = predictable \n“source-to-dest path behaves much like telephone \n§  performance-wise \n§  network actions along source-to-dest path \nNetwork Layer 4-13 \nVC implementation \na VC consists of: \n1.  path from source to destination \n2.  VC numbers, one number for each link along path \n3.  entries in forwarding tables in routers along path \npacket belonging to VC carries VC number \n(rather than dest address) \nVC number can be changed on each link. \nnew VC number comes from forwarding table \nNetwork Layer 4-14 \nVC forwarding table \nIncoming interface    Incoming VC #     Outgoing interface    Outgoing VC # \n1                          12                               3                          22 \n2                          63                               1                          18  \n3                           7                                2                          17 \n1                          97                               3                           87 \n…                          …                                …                            … \nforwarding table in \nnorthwest router: \nVC routers maintain connection state information! \nNetwork Layer 4-15 \napplication \nVirtual circuits: signaling protocols \nv  used to setup, maintain  teardown VC \nv  used in ATM, frame-relay, X.25 \nv  not used in today’s Internet \n1. initiate call \n2. incoming call \n3. accept call \n4. call connected \n5. data flow begins \n6. receive data \napplication \nNetwork Layer 4-16 \nDatagram networks \nv  no call setup at network layer \nv  routers: no state about end-to-end connections \n§  no network-level concept of “connection” \nv  packets forwarded using destination host address \n1. send datagrams \napplication \napplication \n2. receive datagrams \nNetwork Layer 4-17 \nDatagram forwarding  table \nIP destination address in  \narriving packet’s header \nrouting algorithm \nlocal forwarding table \ndest address output  link \naddress-range 1 \naddress-range 2 \naddress-range 3 \naddress-range 4 \n4 billion IP addresses, so \nrather than list individual \ndestination address \nlist range of addresses \n(aggregate table entries) \nNetwork Layer 4-18 \nDestination Address Range \n11001000 00010111 00010000 00000000 \n11001000 00010111 00010111 11111111 \n11001000 00010111 00011000 00000000 \n11001000 00010111 00011000 11111111   \n11001000 00010111 00011001 00000000 \n11001000 00010111 00011111 11111111   \nLink Interface \nQ: but what happens if ranges don’t divide up so nicely?  \nDatagram forwarding  table \nNetwork Layer 4-19 \nLongest prefix matching \nDestination Address Range                         \n11001000 00010111 00010*** *********  \n11001000 00010111 00011000 ********* \n11001000 00010111 00011*** ********* \nDA: 11001000  00010111  00011000  10101010  \nDA: 11001000  00010111  00010110  10100001  \nwhich interface? \nwhich interface? \nwhen looking for forwarding table entry for given \ndestination address, use longest address prefix that \nmatches destination address. \nlongest prefix matching \nLink interface \nNetwork Layer 4-20 \nDatagram or VC network: why? \nInternet (datagram) \nv  data exchange among \n§  “elastic” service, no strict \ntiming req.  \nv  many link types  \n§  different characteristics \n§  uniform service difficult \nv  “smart” end systems \n(computers) \n§  can adapt, perform control, \nerror recovery \n§  simple inside network, \ncomplexity at “edge” \nv  evolved from telephony \nv  human conversation:  \n§  strict timing, reliability \nrequirements \n§  need for guaranteed service \nv  “dumb” end systems \n§  telephones \n§  complexity inside \nNetwork Layer 4-21 \n4.1 introduction \n4.2 virtual circuit and \ndatagram networks \n4.3 what’s inside a router \n4.4 IP: Internet Protocol \n§  datagram format \n§  IPv4 addressing \n4.5 routing algorithms \n§  link state \n§  distance vector \n§  hierarchical routing \n4.6 routing in the Internet \n4.7 broadcast and multicast \nChapter 4: outline \nNetwork Layer 4-22 \nRouter architecture overview \ntwo key router functions:  \nv  run routing algorithms/protocol (RIP, OSPF, BGP) \nv  forwarding datagrams from incoming to outgoing link \nrouter input ports \nrouter output ports \nforwarding data \nplane  (hardware) \nrouting, management \ncontrol plane (software) \nforwarding tables computed, \npushed to input ports \nNetwork Layer 4-23 \ntermination \nInput port functions \ndecentralized switching:  \nv  given datagram dest., lookup output port \nusing forwarding table in input port \nmemory (“match plus action”) \nv  goal: complete input port processing at \n‘line speed’ \nv  queuing: if datagrams arrive faster than \nforwarding rate into switch fabric \nphysical layer: \nbit-level reception \ndata link layer: \ne.g., Ethernet \nsee chapter 5 \nNetwork Layer 4-24 \nSwitching fabrics \nv  transfer packet from input buffer to appropriate \noutput buffer \nv  switching rate: rate at which packets can be \ntransfer from inputs to outputs \n§  often measured as multiple of input/output line rate \n§  N inputs: switching rate N times line rate desirable \nv  three types of switching fabrics \nNetwork Layer 4-25 \nSwitching via memory \nfirst generation routers: \nv traditional computers with switching under direct control \nv packet copied to system’s memory \nv  speed limited by memory bandwidth (2 bus crossings per \nNetwork Layer 4-26 \nSwitching via a bus \nv  datagram from input port memory \n    to output port memory via a \nv  bus contention:  switching speed \nlimited by bus bandwidth \nv  32 Gbps bus, Cisco 5600: sufficient \nspeed for access and enterprise \nNetwork Layer 4-27 \nSwitching via interconnection network \nv  overcome  bus bandwidth limitations \nv  banyan networks, crossbar, other \ninterconnection nets initially \ndeveloped to connect processors in \nmultiprocessor \nv  advanced design: fragmenting \ndatagram into fixed length cells, \nswitch cells through the fabric.  \nv  Cisco 12000: switches 60 Gbps \nthrough the interconnection \nNetwork Layer 4-28 \nOutput ports \nv  buffering required when datagrams arrive \nfrom fabric faster than the transmission \nv  scheduling discipline chooses among queued \ndatagrams for transmission \ntermination \nThis slide in HUGELY important! \nDatagram (packets) can be lost \ndue to congestion, lack of buffers \nPriority scheduling – who gets best \nperformance, network neutrality \nNetwork Layer 4-29 \nOutput port queueing \nv  buffering when arrival rate via switch exceeds \noutput line speed \nv  queueing (delay) and loss due to output port buffer \nat t, packets more \nfrom input to output \none packet time later \nNetwork Layer 4-30 \nHow much buffering? \nv  RFC 3439 rule of thumb: average buffering equal \nto “typical” RTT (say 250 msec) times link \n§  e.g., C = 10 Gpbs link: 2.5 Gbit buffer \nv  recent recommendation: with N flows, buffering \nNetwork Layer 4-31 \nInput port queuing \nv  fabric slower than input ports combined -> queueing may \noccur at input queues  \n§  queueing delay and loss due to input buffer overflow! \nv  Head-of-the-Line (HOL) blocking: queued datagram at front \nof queue prevents others in queue from moving forward \noutput port contention: \nonly one red datagram can be \ntransferred. \nlower red packet is blocked \none packet time \nlater: green packet \nexperiences HOL \nNetwork Layer 4-32 \n4.1 introduction \n4.2 virtual circuit and \ndatagram networks \n4.3 what’s inside a router \n4.4 IP: Internet Protocol \n§  datagram format \n§  IPv4 addressing \n4.5 routing algorithms \n§  link state \n§  distance vector \n§  hierarchical routing \n4.6 routing in the Internet \n4.7 broadcast and multicast \nChapter 4: outline \nNetwork Layer 4-33 \nThe Internet network layer \nhost, router network layer functions: \nrouting protocols \n•  path selection \n•  RIP, OSPF, BGP \nIP protocol \n•  addressing conventions \n•  datagram format \n•  packet handling conventions \nICMP protocol \n•  error reporting \n•  router “signaling” \ntransport layer: TCP, UDP \nphysical layer \nNetwork Layer 4-34 \n(variable length, \ntypically a TCP  \nor UDP segment) \n16-bit identifier \n32 bit source IP address \n32 bit destination IP address \noptions (if any) \nIP datagram format \nIP protocol version \nheader length \nupper layer protocol \nto deliver payload to \ntotal datagram \nlength (bytes) \n“type” of data  \nfragmentation/ \nremaining hops \n(decremented at  \neach router) \ne.g. timestamp, \nrecord route \ntaken, specify \nlist of routers  \nhow much overhead? \nv  20 bytes of TCP \nv  20 bytes of IP \nv  = 40 bytes + app \nlayer overhead \nNetwork Layer 4-35 \nIP fragmentation, reassembly \nv  network links have MTU \n(max.transfer size) - \nlargest possible link-level \n§  different link types, \ndifferent MTUs  \nv  large IP datagram divided \n(“fragmented”) within net \n§  one datagram becomes \nseveral datagrams \n§  “reassembled” only at \nfinal destination \n§  IP header bits used to \nidentify, order related \nfragmentation:  \nin: one large datagram \nout: 3 smaller datagrams \nNetwork Layer 4-36 \none large datagram becomes \nseveral smaller datagrams \nv  4000 byte datagram \nv  MTU = 1500 bytes \n1480 bytes in  \nIP fragmentation, reassembly \nNetwork Layer 4-37 \n4.1 introduction \n4.2 virtual circuit and \ndatagram networks \n4.3 what’s inside a router \n4.4 IP: Internet Protocol \n§  datagram format \n§  IPv4 addressing \n4.5 routing algorithms \n§  link state \n§  distance vector \n§  hierarchical routing \n4.6 routing in the Internet \n4.7 broadcast and multicast \nChapter 4: outline \nNetwork Layer 4-38 \nIP addressing: introduction \nv  IP address: 32-bit \nidentifier for host, router \nv  interface: connection \nbetween host/router and \nphysical link \n§  router’s typically have \nmultiple interfaces \n§  host typically has one or \ntwo interfaces (e.g., wired \nEthernet, wireless 802.11) \nv  IP addresses associated \nwith each interface \n223.1.1.1 = 11011111 00000001 00000001 00000001 \nNetwork Layer 4-39 \nIP addressing: introduction \nQ: how are interfaces \nactually connected? \nA: we’ll learn about that \nin chapter 5, 6. \nA: wired Ethernet interfaces \nconnected by Ethernet switches \nA: wireless WiFi interfaces \nconnected by WiFi base station \nFor now: don’t need to worry \nabout how one interface is \nconnected to another (with no \nintervening router)  \nNetwork Layer 4-40 \nv IP address:  \n§ subnet part - high order \n§ host part - low order \nv what’s a subnet ? \n§ device interfaces with \nsame subnet part of IP \n§ can physically reach \neach other without \nintervening router \nnetwork consisting of 3 subnets \nNetwork Layer 4-41 \nv  to determine the \nsubnets, detach each \ninterface from its host \nor router, creating \nislands of isolated \nv  each isolated network \nis called a subnet \nsubnet mask: /24 \n223.1.1.0/24 \n223.1.2.0/24 \n223.1.3.0/24 \nNetwork Layer 4-42 \nNetwork Layer 4-43 \nIP addressing: CIDR \nCIDR: Classless InterDomain Routing \n§  subnet portion of address of arbitrary length \n§  address format: a.b.c.d/x, where x is # bits in \nsubnet portion of address \n11001000  00010111  00010000  00000000 \n200.23.16.0/23 \nNetwork Layer 4-44 \nIP addresses: how to get one? \nQ: How does a host get IP address? \nv  hard-coded by system admin in a file \n§  Windows: control-panel->network->configuration->tcp/\nip->properties \n§  UNIX: /etc/rc.config \nv  DHCP: Dynamic Host Configuration Protocol: \ndynamically get address from as server \n§  “plug-and-play”  \nNetwork Layer 4-45 \nDHCP: Dynamic Host Configuration Protocol \ngoal: allow host to dynamically obtain its IP address from network \nserver when it joins network \n§  can renew its lease on address in use \n§  allows reuse of addresses (only hold address while \nconnected/“on”) \n§  support for mobile users who want to join network (more \nDHCP overview: \n§  host broadcasts “DHCP discover” msg [optional] \n§  DHCP server responds with “DHCP offer” msg [optional] \n§  host requests IP address: “DHCP request” msg \n§  DHCP server sends address: “DHCP ack” msg  \nNetwork Layer 4-46 \nDHCP client-server scenario \n223.1.1.0/24 \n223.1.2.0/24 \n223.1.3.0/24 \narriving DHCP \nclient needs  \naddress in this \nNetwork Layer 4-47 \nDHCP server: 223.1.2.5 \nDHCP discover \nsrc : 0.0.0.0, 68     \ndest.: 255.255.255.255,67 \nyiaddr:    0.0.0.0 \ntransaction ID: 654 \nsrc: 223.1.2.5, 67      \ndest:  255.255.255.255, 68 \nyiaddrr: 223.1.2.4 \ntransaction ID: 654 \nlifetime: 3600 secs \nDHCP request \nsrc:  0.0.0.0, 68     \ndest::  255.255.255.255, 67 \nyiaddrr: 223.1.2.4 \ntransaction ID: 655 \nlifetime: 3600 secs \nsrc: 223.1.2.5, 67      \ndest:  255.255.255.255, 68 \nyiaddrr: 223.1.2.4 \ntransaction ID: 655 \nlifetime: 3600 secs \nDHCP client-server scenario \nBroadcast: is there a \nDHCP server out there? \nBroadcast: I’m a DHCP \nserver! Here’s an IP \naddress you can use \nBroadcast: OK.  I’ll take \nthat IP address! \nBroadcast: OK.  You’ve \ngot that IP address! \nNetwork Layer 4-48 \nDHCP: more than IP addresses \nDHCP can return more than just allocated IP \naddress on subnet: \n§  address of first-hop router for client \n§  name and IP address of DNS sever \n§  network mask (indicating network versus host portion \nof address) \nNetwork Layer 4-49 \nv  connecting laptop needs \nits IP address, addr of \nfirst-hop router, addr of \nDNS server: use DHCP \nrouter with DHCP  \nserver built into  \nv  DHCP request encapsulated \nin UDP, encapsulated in IP, \nencapsulated in 802.1 \n v  Ethernet frame broadcast \n(dest: FFFFFFFFFFFF) on LAN, \nreceived at router running \nDHCP server \nv  Ethernet demuxed to IP \ndemuxed, UDP demuxed to \nDHCP: example \nNetwork Layer 4-50 \nv  DCP server formulates \nDHCP ACK containing \nclient’s IP address, IP \naddress of first-hop \nrouter for client, name & \nIP address of DNS server \nv  encapsulation of DHCP \nserver, frame forwarded \nto client, demuxing up to \nDHCP at client \nDHCP: example \nrouter with DHCP  \nserver built into  \nv  client now knows its IP \naddress, name and IP \naddress of DSN server, IP \naddress of its first-hop \nNetwork Layer 4-51 \nDHCP: Wireshark \noutput (home LAN) \nMessage type: Boot Reply (2) \nHardware type: Ethernet \nHardware address length: 6 \nTransaction ID: 0x6b3a11b7 \nSeconds elapsed: 0 \nBootp flags: 0x0000 (Unicast) \nClient IP address: 192.168.1.101 (192.168.1.101) \nYour (client) IP address: 0.0.0.0 (0.0.0.0) \nNext server IP address: 192.168.1.1 (192.168.1.1) \nRelay agent IP address: 0.0.0.0 (0.0.0.0) \nClient MAC address: Wistron_23:68:8a (00:16:d3:23:68:8a) \nServer host name not given \nBoot file name not given \nMagic cookie: (OK) \nOption: (t=53,l=1) DHCP Message Type = DHCP ACK \nOption: (t=54,l=4) Server Identifier = 192.168.1.1 \nOption: (t=1,l=4) Subnet Mask = 255.255.255.0 \nOption: (t=3,l=4) Router = 192.168.1.1 \nOption: (6) Domain Name Server \n     Length: 12; Value: 445747E2445749F244574092;  \n      IP Address: 68.87.71.226; \n      IP Address: 68.87.73.242;  \n      IP Address: 68.87.64.146 \nOption: (t=15,l=20) Domain Name = \"hsd1.ma.comcast.net.\" \nMessage type: Boot Request (1) \nHardware type: Ethernet \nHardware address length: 6 \nTransaction ID: 0x6b3a11b7 \nSeconds elapsed: 0 \nBootp flags: 0x0000 (Unicast) \nClient IP address: 0.0.0.0 (0.0.0.0) \nYour (client) IP address: 0.0.0.0 (0.0.0.0) \nNext server IP address: 0.0.0.0 (0.0.0.0) \nRelay agent IP address: 0.0.0.0 (0.0.0.0) \nClient MAC address: Wistron_23:68:8a (00:16:d3:23:68:8a) \nServer host name not given \nBoot file name not given \nMagic cookie: (OK) \nOption: (t=53,l=1) DHCP Message Type = DHCP Request \nOption: (61) Client identifier \n     Length: 7; Value: 010016D323688A;  \n     Hardware type: Ethernet \n     Client MAC address: Wistron_23:68:8a (00:16:d3:23:68:8a) \nOption: (t=50,l=4) Requested IP Address = 192.168.1.101 \nOption: (t=12,l=5) Host Name = \"nomad\" \nOption: (55) Parameter Request List \n     Length: 11; Value: 010F03062C2E2F1F21F92B \n     1 = Subnet Mask; 15 = Domain Name \n     3 = Router; 6 = Domain Name Server \n     44 = NetBIOS over TCP/IP Name Server \nNetwork Layer 4-52 \nIP addresses: how to get one? \nQ: how does network get subnet part of IP addr? \nA: gets allocated portion of its provider ISP’s address \nISP's block          11001000  00010111  00010000  00000000    200.23.16.0/20  \nOrganization 0    11001000  00010111  00010000  00000000    200.23.16.0/23  \nOrganization 1    11001000  00010111  00010010  00000000    200.23.18.0/23  \nOrganization 2    11001000  00010111  00010100  00000000    200.23.20.0/23  \n   ...                                          …..                                   ….                …. \nOrganization 7    11001000  00010111  00011110  00000000    200.23.30.0/23  \nNetwork Layer 4-53 \nHierarchical addressing: route aggregation \n“Send me anything \nwith addresses  \n200.23.16.0/20” \n200.23.16.0/23 \n200.23.18.0/23 \n200.23.30.0/23 \nFly-By-Night-ISP \nOrganization 0 \nOrganization 7 \nOrganization 1 \n“Send me anything \nwith addresses  \n199.31.0.0/16” \n200.23.20.0/23 \nOrganization 2 \nhierarchical addressing allows efficient advertisement of routing  \ninformation: \nNetwork Layer 4-54 \nISPs-R-Us has a more specific route to Organization 1 \n“Send me anything \nwith addresses  \n200.23.16.0/20” \n200.23.16.0/23 \n200.23.18.0/23 \n200.23.30.0/23 \nFly-By-Night-ISP \nOrganization 0 \nOrganization 7 \nOrganization 1 \n“Send me anything \nwith addresses  \nbeginning 199.31.0.0/16 \nor 200.23.18.0/23” \n200.23.20.0/23 \nOrganization 2 \nHierarchical addressing: more specific routes \nNetwork Layer 4-55 \nIP addressing: the last word... \nQ: how does an ISP get block of addresses? \nA: ICANN: Internet Corporation for Assigned  \n     Names and Numbers http://www.icann.org/ \n§  allocates addresses \n§  manages DNS \n§  assigns domain names, resolves disputes \nNetwork Layer 4-56 \nNAT: network address translation \n138.76.29.7 \nlocal network \n(e.g., home network) \ndatagrams with source or  \ndestination in this network \nhave 10.0.0/24 address for  \nsource, destination (as usual) \nall datagrams leaving local \nnetwork have same single \nsource NAT IP address: \n138.76.29.7,different source \nport numbers \nNetwork Layer 4-57 \nmotivation: local network uses just one IP address as far \nas outside world is concerned: \n§  range of addresses not needed from ISP:  just one \nIP address for all devices \n§  can change addresses of devices in local network \nwithout notifying outside world \n§  can change ISP without changing addresses of \ndevices in local network \n§  devices inside local net not explicitly addressable, \nvisible by outside world (a security plus) \nNAT: network address translation \nNetwork Layer 4-58 \n   implementation: NAT router must: \n§  outgoing datagrams: replace (source IP address, port #) of \nevery outgoing datagram to (NAT IP address, new port #) \n. . . remote clients/servers will respond using (NAT IP \naddress, new port #) as destination addr \n§  remember (in NAT translation table) every (source IP address, \nport #)  to (NAT IP address, new port #) translation pair \n§  incoming datagrams: replace (NAT IP address, new port #) in \ndest fields of every incoming datagram with corresponding \n(source IP address, port #) stored in NAT table \nNAT: network address translation \nNetwork Layer 4-59 \nS: 10.0.0.1, 3345 \nD: 128.119.40.186, 80 \n138.76.29.7 \n1: host 10.0.0.1  \nsends datagram to  \n128.119.40.186, 80 \nNAT translation table \nWAN side addr        LAN side addr \n138.76.29.7, 5001   10.0.0.1, 3345 \n……                                         …… \nS: 128.119.40.186, 80  \nD: 10.0.0.1, 3345 \nS: 138.76.29.7, 5001 \nD: 128.119.40.186, 80 \n2: NAT router \nchanges datagram \nsource addr from \n10.0.0.1, 3345 to \n138.76.29.7, 5001, \nupdates table \nS: 128.119.40.186, 80  \nD: 138.76.29.7, 5001 \n3: reply arrives \n dest. address: \n 138.76.29.7, 5001 \n4: NAT router \nchanges datagram \ndest addr from \n138.76.29.7, 5001 to 10.0.0.1, 3345  \nNAT: network address translation \nNetwork Layer 4-60 \nv  16-bit port-number field:  \n§  60,000 simultaneous connections with a single \nLAN-side address! \nv  NAT is controversial: \n§  routers should only process up to layer 3 \n§  violates end-to-end argument \n•  NAT possibility must be taken into account by app \ndesigners, e.g., P2P applications \n§  address shortage should instead be solved by \nNAT: network address translation \nNetwork Layer 4-61 \nNAT traversal problem \nv  client wants to connect to \nserver with address 10.0.0.1 \n§  server address 10.0.0.1 local to \nLAN (client can’t use it as \ndestination addr) \n§  only one externally visible NATed \naddress: 138.76.29.7 \nv  solution1: statically configure \nNAT to forward incoming \nconnection requests at given \nport to server \n§  e.g., (123.76.29.7, port 2500) \nalways forwarded to 10.0.0.1 port \n138.76.29.7 \nNetwork Layer 4-62 \nNAT traversal problem \nv  solution 2: Universal Plug and Play \n(UPnP) Internet Gateway Device \n(IGD) Protocol.  Allows NATed \nv  learn public IP address \n(138.76.29.7) \nv  add/remove port mappings \n(with lease times) \ni.e., automate static NAT port \nmap configuration \nNetwork Layer 4-63 \nNAT traversal problem \nv  solution 3: relaying (used in Skype) \n§  NATed client establishes connection to relay \n§  external client connects to relay \n§  relay bridges packets between to connections \n138.76.29.7 \n1. connection to \nrelay initiated \nby NATed host \n2. connection to \nrelay initiated \n3. relaying  \nestablished \nNetwork Layer 4-64 \n4.1 introduction \n4.2 virtual circuit and \ndatagram networks \n4.3 what’s inside a router \n4.4 IP: Internet Protocol \n§  datagram format \n§  IPv4 addressing \n4.5 routing algorithms \n§  link state \n§  distance vector \n§  hierarchical routing \n4.6 routing in the Internet \n4.7 broadcast and multicast \nChapter 4: outline \nNetwork Layer 4-65 \nICMP: internet control message protocol \nv  used by hosts & routers \nto communicate network-\nlevel information \n§  error reporting: \nunreachable host, network, \nport, protocol \n§  echo request/reply (used by \nv  network-layer “above” IP: \n§  ICMP msgs carried in IP \nv  ICMP message: type, code \nplus first 8 bytes of IP \ndatagram causing error \nType  Code  description \n0        0         echo reply (ping) \n3        0         dest. network unreachable \n3        1         dest host unreachable \n3        2         dest protocol unreachable \n3        3         dest port unreachable \n3        6         dest network unknown \n3        7         dest host unknown \n4        0         source quench (congestion \n                     control - not used) \n8        0         echo request (ping) \n9        0         route advertisement \n10      0         router discovery \n11      0         TTL expired \n12      0         bad IP header \nNetwork Layer 4-66 \nTraceroute and ICMP \nv  source sends series of \nUDP segments to dest \n§  first set has TTL =1 \n§  second set has TTL=2, etc. \n§  unlikely port number \nv  when nth set of datagrams \narrives to nth router: \n§  router discards datagrams \n§  and sends source ICMP \nmessages (type 11, code 0) \n§  ICMP messages includes \nname of router & IP address \nv  when ICMP messages \narrives, source records \nstopping criteria: \nv  UDP segment eventually \narrives at destination host \nv  destination returns ICMP \n“port unreachable” \nmessage (type 3, code 3) \nv  source stops \nNetwork Layer 4-67 \nIPv6: motivation \nv  initial motivation: 32-bit address space soon to be \ncompletely allocated.   \nv  additional motivation: \n§  header format helps speed processing/forwarding \n§  header changes to facilitate QoS  \nIPv6 datagram format:  \n§  fixed-length 40 byte header \n§  no fragmentation allowed \nNetwork Layer 4-68 \nIPv6 datagram format \npriority:  identify priority among datagrams in flow \nflow Label: identify datagrams in same “flow.”  \n                    (concept of“flow” not well defined). \nnext header: identify upper layer protocol for data  \ndestination address \nsource address \npayload len \nNetwork Layer 4-69 \nOther changes from IPv4 \nv  checksum: removed entirely to reduce processing \ntime at each hop \nv  options: allowed, but outside of header, indicated \nby “Next Header” field \nv  ICMPv6: new version of ICMP \n§  additional message types, e.g. “Packet Too Big” \n§  multicast group management functions \nNetwork Layer 4-70 \nTransition from IPv4 to IPv6 \nv  not all routers can be upgraded simultaneously \n§  no “flag days” \n§  how will network operate with mixed IPv4 and \nIPv6 routers?  \nv  tunneling: IPv6 datagram carried as payload in IPv4 \ndatagram among IPv4 routers \nIPv4 source, dest addr  \nIPv4 header fields  \nIPv4 datagram \nIPv6 datagram \nIPv4 payload  \nUDP/TCP payload \nIPv6 source dest addr \nIPv6 header fields \nNetwork Layer 4-71 \nphysical view: \nlogical view: \nIPv4 tunnel  \nconnecting IPv6 routers \nNetwork Layer 4-72 \nIPv6 inside \nIPv6 inside \nphysical view: \nlogical view: \nIPv4 tunnel  \nconnecting IPv6 routers \nNetwork Layer 4-73 \nIPv6: adoption \nv  US National Institutes of Standards estimate [2013]: \n§  ~3% of industry IP routers \n§  ~11% of US gov’t routers \nv  Long (long!) time for deployment, use \n§  20 years and counting! \n§  think of application-level changes in last 20 years: WWW, \nFacebook, … \nNetwork Layer 4-74 \n4.1 introduction \n4.2 virtual circuit and \ndatagram networks \n4.3 what’s inside a router \n4.4 IP: Internet Protocol \n§  datagram format \n§  IPv4 addressing \n4.5 routing algorithms \n§  link state \n§  distance vector \n§  hierarchical routing \n4.6 routing in the Internet \n4.7 broadcast and multicast \nChapter 4: outline \nNetwork Layer 4-75 \nIP destination address in  \narriving packet’s header \nrouting algorithm \nlocal forwarding table \ndest address output  link \naddress-range 1 \naddress-range 2 \naddress-range 3 \naddress-range 4 \nInterplay between routing, forwarding \nrouting algorithm determines \nend-end-path through network \nforwarding table determines \nlocal forwarding at this router \nNetwork Layer 4-76 \ngraph: G = (N,E) \nN = set of routers = { u, v, w, x, y, z } \nE = set of links ={ (u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z) } \nGraph abstraction \naside: graph abstraction is useful in other network contexts, e.g.,  \nP2P, where N is set of peers and E is set of TCP connections \nNetwork Layer 4-77 \nGraph abstraction: costs \nc(x,x’) = cost of link (x,x’) \n      e.g., c(w,z) = 5 \ncost could always be 1, or  \ninversely related to bandwidth, \nor inversely related to  \ncost of path (x1, x2, x3,…, xp) = c(x1,x2) + c(x2,x3) + … + c(xp-1,xp)   \nkey question: what is the least-cost path between u and z ? \nrouting algorithm: algorithm that finds that least cost path \nNetwork Layer 4-78 \nRouting algorithm classification \nQ: global or decentralized \ninformation? \nv  all routers have complete \ntopology, link cost info \nv  “link state” algorithms \ndecentralized:  \nv  router knows physically-\nconnected neighbors, link \ncosts to neighbors \nv  iterative process of \ncomputation, exchange of \ninfo with neighbors \nv  “distance vector” algorithms \nQ: static or dynamic? \nv  routes change slowly over \nv  routes change more \n§  periodic update \n§  in response to link \ncost changes \nNetwork Layer 4-79 \n4.1 introduction \n4.2 virtual circuit and \ndatagram networks \n4.3 what’s inside a router \n4.4 IP: Internet Protocol \n§  datagram format \n§  IPv4 addressing \n4.5 routing algorithms \n§  link state \n§  distance vector \n§  hierarchical routing \n4.6 routing in the Internet \n4.7 broadcast and multicast \nChapter 4: outline \nNetwork Layer 4-80 \nA Link-State Routing Algorithm \nDijkstra’s algorithm \nv  net topology, link costs \nknown to all nodes \n§  accomplished via “link state \n§  all nodes have same info \nv  computes least cost paths \nfrom one node (‘source”) \nto all other nodes \n§  gives forwarding table for \nv  iterative: after k \niterations, know least cost \npath to k dest.’s \nv  c(x,y): link cost from \nnode x to y;  = ∞ if not \ndirect neighbors \nv  D(v): current value of \ncost of path from source \nv  p(v): predecessor node \nalong path from source to \nv  N': set of nodes whose \nleast cost path definitively \nNetwork Layer 4-81 \nDijsktra’s Algorithm \n1  Initialization:  \n2    N' = {u}  \n3    for all nodes v  \n4      if v adjacent to u  \n5          then D(v) = c(u,v)  \n6      else D(v) = ∞  \n9     find w not in N' such that D(w) is a minimum  \n10    add w to N'  \n11    update D(v) for all v adjacent to w and not in N' :  \n12       D(v) = min( D(v), D(w) + c(w,v) )  \n13    /* new cost to v is either old cost to v or known  \n14     shortest path cost to w plus cost from w to v */  \n15  until all nodes in N'  \nNetwork Layer 4-82 \nDijkstra’s algorithm: example \nv  construct shortest path tree by \ntracing predecessor nodes \nv  ties can exist (can be broken \narbitrarily) \nNetwork Layer 4-83 \nDijkstra’s algorithm: another example \nNetwork Layer 4-84 \nDijkstra’s algorithm: example (2)  \nresulting shortest-path tree from u: \ndestination \nresulting forwarding table in u: \nNetwork Layer 4-85 \nDijkstra’s algorithm, discussion \nalgorithm complexity: n nodes \nv  each iteration: need to check all nodes, w, not in N \nv  n(n+1)/2 comparisons: O(n2) \nv  more efficient implementations possible: O(nlogn) \noscillations possible: \nv  e.g., support link cost equals amount of carried traffic: \ngiven these costs, \nfind new routing…. \nresulting in new costs \ngiven these costs, \nfind new routing…. \nresulting in new costs \ngiven these costs, \nfind new routing…. \nresulting in new costs \nNetwork Layer 4-86 \n4.1 introduction \n4.2 virtual circuit and \ndatagram networks \n4.3 what’s inside a router \n4.4 IP: Internet Protocol \n§  datagram format \n§  IPv4 addressing \n4.5 routing algorithms \n§  link state \n§  distance vector \n§  hierarchical routing \n4.6 routing in the Internet \n4.7 broadcast and multicast \nChapter 4: outline \nNetwork Layer 4-87 \nDistance vector algorithm  \nBellman-Ford equation (dynamic programming) \n   dx(y) := cost of least-cost path from x to y \n   dx(y) = min {c(x,v) + dv(y) } \ncost to neighbor v \nmin taken over all neighbors v of x \ncost from neighbor v to destination y \nNetwork Layer 4-88 \nBellman-Ford example  \nclearly, dv(z) = 5, dx(z) = 3, dw(z) = 3 \ndu(z) = min { c(u,v) + dv(z), \n                    c(u,x) + dx(z), \n                    c(u,w) + dw(z) } \n         = min {2 + 5, \n                    5 + 3}  = 4 \nnode achieving minimum is next \nhop in shortest path, used in forwarding table \nB-F equation says: \nNetwork Layer 4-89 \nDistance vector algorithm  \nv  Dx(y) = estimate of least cost from x to y \n§  x maintains  distance vector Dx = [Dx(y): y є N ] \n§  knows cost to each neighbor v: c(x,v) \n§  maintains its neighbors’ distance vectors. For \neach neighbor v, x maintains  \nDv = [Dv(y): y є N ] \nNetwork Layer 4-90 \nv  from time-to-time, each node sends its own \ndistance vector estimate to neighbors \nv  when x receives new DV estimate from neighbor, \nit updates its own DV using B-F equation: \nDx(y) ← minv{c(x,v) + Dv(y)}  for each node y ∊ N \nv  under minor, natural conditions, the estimate Dx(y) \nconverge to the actual least cost dx(y)  \nDistance vector algorithm  \nNetwork Layer 4-91 \niterative, asynchronous: \neach local iteration \nv  local link cost change  \nv  DV update message from \ndistributed: \nv  each node notifies \nneighbors only when its \n§  neighbors then notify their \nneighbors if necessary \nwait for (change in local link \ncost or msg from neighbor) \nrecompute estimates \nif DV to any dest has \nchanged, notify neighbors  \nDistance vector algorithm  \nNetwork Layer 4-92 \nDx(y) = min{c(x,y) + Dy(y), c(x,z) + Dz(y)}  \n             = min{2+0 , 7+1} = 2 \nDx(z) = min{c(x,y) +  \n      Dy(z), c(x,z) + Dz(z)}  \n= min{2+1 , 7+0} = 3 \nNetwork Layer 4-93 \nDx(y) = min{c(x,y) + Dy(y), c(x,z) + Dz(y)}  \n             = min{2+0 , 7+1} = 2 \nDx(z) = min{c(x,y) +  \n      Dy(z), c(x,z) + Dz(z)}  \n= min{2+1 , 7+0} = 3 \nNetwork Layer 4-94 \nDistance vector: link cost changes \nlink cost changes: \nv  node detects local link cost change \nv  updates routing info, recalculates  \ndistance vector \nv  if DV changes, notify neighbors  \nt0 : y detects link-cost change, updates its DV, informs its \n t1 : z receives update from y, updates its table, computes new \nleast cost to x , sends its neighbors its DV. \nt2 : y receives z’s update, updates its distance table.  y’s least costs \ndo not change, so y  does not send a message to z.  \nNetwork Layer 4-95 \nDistance vector: link cost changes \nlink cost changes: \nv  node detects local link cost change \nv  bad news travels slow - “count to \ninfinity” problem! \nv  44 iterations before algorithm \nstabilizes: see text \npoisoned reverse:  \nv  If Z routes through Y to get to X : \n§  Z tells Y its (Z’s) distance to X is infinite (so Y won’t route \nto X via Z) \nv  will this completely solve count to infinity problem? \nNetwork Layer 4-96 \nComparison of LS and DV algorithms \nmessage complexity \nv  LS: with n nodes, E links, O(nE) \nv  DV: exchange between neighbors \n§  convergence time varies \nspeed of convergence \nv  LS: O(n2) algorithm requires \n§  may have oscillations \nv  DV: convergence time varies \n§  may be routing loops \n§  count-to-infinity problem \nrobustness: what happens if \nrouter malfunctions? \n§  node can advertise incorrect \n§  each node computes only its \n§  DV node can advertise \nincorrect path cost \n§  each node’s table used by \n•  error propagate thru \nNetwork Layer 4-97 \n4.1 introduction \n4.2 virtual circuit and \ndatagram networks \n4.3 what’s inside a router \n4.4 IP: Internet Protocol \n§  datagram format \n§  IPv4 addressing \n4.5 routing algorithms \n§  link state \n§  distance vector \n§  hierarchical routing \n4.6 routing in the Internet \n4.7 broadcast and multicast \nChapter 4: outline \nNetwork Layer 4-98 \nHierarchical routing \nscale: with 600 million \ndestinations: \nv  can’t store all dest’s in \nrouting tables! \nv  routing table exchange \nwould swamp links!  \nadministrative autonomy \nv  internet = network of \nv  each network admin may \nwant to control routing in \nits own network \nour routing study thus far - idealization  \nv  all routers identical \nv  network “flat” \n… not true in practice \nNetwork Layer 4-99 \nv  aggregate routers into \nregions, “autonomous \nsystems” (AS) \nv  routers in same AS \nrun same routing \n§  “intra-AS” routing \n§  routers in different AS \ncan run different intra-\nAS routing protocol \ngateway router: \nv  at “edge” of its own AS \nv  has  link to router in \nHierarchical routing \nNetwork Layer 4-100 \nInterconnected ASes \nv  forwarding table  \nconfigured by both intra- \nand inter-AS routing \n§  intra-AS sets entries \nfor internal dests \n§  inter-AS & intra-AS \nsets entries for \nexternal dests  \nNetwork Layer 4-101 \nInter-AS tasks \nv  suppose router in AS1 \nreceives datagram \ndestined outside of AS1: \n§  router should forward \npacket to gateway \nrouter, but which one? \nlearn which dests are \nreachable through AS2, \nwhich through AS3 \npropagate this \nreachability info to all \nrouters in AS1 \njob of inter-AS routing! \nNetwork Layer 4-102 \nExample: setting forwarding table in router 1d \nv  suppose AS1 learns (via inter-AS protocol) that subnet x \nreachable via AS3 (gateway 1c), but not via AS2 \n§  inter-AS protocol propagates reachability info to all internal \nv  router 1d determines from intra-AS routing info that its \ninterface I  is on the least cost path to 1c \n§  installs forwarding table entry (x,I) \nNetwork Layer 4-103 \nExample: choosing among multiple ASes \nv  now suppose AS1 learns from inter-AS protocol that subnet \nx is reachable from AS3 and from AS2. \nv  to configure forwarding table, router 1d must determine \nwhich gateway it should forward packets towards for dest x \n§  this is also job of inter-AS routing protocol! \nNetwork Layer 4-104 \nlearn from inter-AS  \nprotocol that subnet  \nx is reachable via  \nmultiple gateways \nuse routing info \nfrom intra-AS  \nprotocol to determine \ncosts of least-cost  \npaths to each \nof the gateways \nhot potato routing: \nchoose the gateway \nthat has the  \nsmallest least cost \ndetermine from \nforwarding table the  \ninterface I that leads  \nto least-cost gateway.  \nEnter (x,I) in  \nforwarding table \nExample: choosing among multiple ASes \nv  now suppose AS1 learns from inter-AS protocol that subnet \nx is reachable from AS3 and from AS2. \nv  to configure forwarding table, router 1d must determine \ntowards which gateway it should forward packets for dest x \n§  this is also job of inter-AS routing protocol! \nv  hot potato routing: send packet towards closest of two \nNetwork Layer 4-105 \n4.1 introduction \n4.2 virtual circuit and \ndatagram networks \n4.3 what’s inside a router \n4.4 IP: Internet Protocol \n§  datagram format \n§  IPv4 addressing \n4.5 routing algorithms \n§  link state \n§  distance vector \n§  hierarchical routing \n4.6 routing in the Internet \n4.7 broadcast and multicast \nChapter 4: outline \nNetwork Layer 4-106 \nIntra-AS Routing \nv  also known as interior gateway protocols (IGP) \nv  most common intra-AS routing protocols: \n§  RIP: Routing Information Protocol \n§  OSPF: Open Shortest Path First \n§  IGRP: Interior Gateway Routing Protocol \n(Cisco proprietary) \nNetwork Layer 4-107 \nRIP ( Routing Information Protocol) \nv  included in BSD-UNIX distribution in 1982 \nv  distance vector algorithm \n§  distance metric: # hops (max = 15 hops), each link has cost 1 \n§  DVs exchanged with neighbors every 30 sec in response message (aka \nadvertisement) \n§  each advertisement: list of up to 25 destination subnets (in IP addressing \nsubnet    hops \n      u         1 \n      v         2 \n      x         3 \n      y         3 \n      z         2 \nfrom router A to destination subnets: \nNetwork Layer 4-108 \nRIP: example  \ndestination subnet\n   next  router      # hops to dest \nrouting table in router D \nNetwork Layer 4-109 \ndestination subnet\n   next  router      # hops to dest \nrouting table in router D \n dest     next  hops \nA-to-D advertisement \nRIP: example  \nNetwork Layer 4-110 \nRIP: link failure, recovery  \nif no advertisement heard after 180 sec --> neighbor/\nlink declared dead \n§  routes via neighbor invalidated \n§  new advertisements sent to neighbors \n§  neighbors in turn send out new advertisements (if tables \n§  link failure info quickly (?) propagates to entire net \n§  poison reverse used to prevent ping-pong loops (infinite \ndistance = 16 hops) \nNetwork Layer 4-111 \nRIP table processing \nv  RIP routing tables managed by application-level \nprocess called route-d (daemon) \nv  advertisements sent in UDP packets, periodically \nnetwork       forwarding \n   (IP)             table \nNetwork Layer 4-112 \nOSPF (Open Shortest Path First) \nv  “open”: publicly available \nv  uses link state algorithm  \n§  LS packet dissemination \n§  topology map at each node \n§  route computation using Dijkstra’s algorithm \nv  OSPF advertisement carries one entry per neighbor  \nv  advertisements flooded to entire AS \n§  carried in OSPF messages directly over IP (rather than \nv  IS-IS routing protocol: nearly identical to OSPF \nNetwork Layer 4-113 \nOSPF “advanced” features (not in RIP) \nv  security: all OSPF messages authenticated (to prevent \nmalicious intrusion)  \nv  multiple same-cost paths allowed (only one path in \nv  for each link, multiple cost metrics for different TOS \n(e.g., satellite link cost set “low” for best effort ToS; \nhigh for real time ToS) \nv  integrated uni- and multicast support:  \n§  Multicast OSPF (MOSPF) uses same topology data \nbase as OSPF \nv  hierarchical OSPF in large domains. \nNetwork Layer 4-114 \nHierarchical OSPF \nboundary router \nbackbone router \nNetwork Layer 4-115 \nv  two-level hierarchy: local area, backbone. \n§  link-state advertisements only in area  \n§  each nodes has detailed area topology; only know \ndirection (shortest path) to nets in other areas. \nv  area border routers: “summarize” distances  to nets in \nown area, advertise to other Area Border routers. \nv  backbone routers: run OSPF routing limited to \nv  boundary routers: connect to other AS’s. \nHierarchical OSPF \nNetwork Layer 4-116 \nInternet inter-AS routing: BGP \nv  BGP (Border Gateway Protocol): the de facto \ninter-domain routing protocol \n§  “glue that holds the Internet together” \nv  BGP provides each AS a means to: \n§  eBGP: obtain subnet reachability information from \nneighboring ASs. \n§  iBGP: propagate reachability information to all AS-\ninternal routers. \n§  determine “good” routes to other networks based on \nreachability information and policy. \nv  allows subnet to advertise its existence to rest of \nInternet: “I am here” \nNetwork Layer 4-117 \nv  when AS3 advertises a prefix to AS1: \n§  AS3 promises it will forward datagrams towards that prefix \n§  AS3 can aggregate prefixes in its advertisement \nv  BGP session: two BGP routers (“peers”) exchange BGP \n§  advertising paths to different destination network prefixes (“path vector” \n§  exchanged over semi-permanent TCP connections \nNetwork Layer 4-118 \nBGP basics: distributing path information \nv  using eBGP session between 3a and 1c, AS3 sends prefix \nreachability info to AS1. \n§  1c can then use iBGP do distribute new prefix info to all routers \n§  1b can then re-advertise new reachability info to AS2 over 1b-\nto-2a eBGP session \nv  when router learns of new prefix, it creates entry for \nprefix in its forwarding table. \neBGP session \niBGP session \nNetwork Layer 4-119 \nPath attributes and BGP routes \nv  advertised prefix includes BGP attributes  \n§  prefix + attributes = “route” \nv  two important attributes: \n§  AS-PATH: contains ASs through which prefix \nadvertisement has passed: e.g., AS 67, AS 17  \n§  NEXT-HOP: indicates specific internal-AS router to next-\nhop AS. (may be multiple links from current AS to next-\nv  gateway router receiving route advertisement uses \nimport policy to accept/decline \n§  e.g., never route through AS x \n§  policy-based routing \nNetwork Layer 4-120 \nBGP route selection \nv  router may learn about more than 1 route to \ndestination AS, selects route based on: \n1.  local preference value attribute: policy decision \n2.  shortest AS-PATH  \n3.  closest NEXT-HOP router: hot potato routing \n4.  additional criteria  \nNetwork Layer 4-121 \nBGP messages \nv  BGP messages exchanged between peers over TCP \nv  BGP messages: \n§  OPEN: opens TCP connection to peer and authenticates \n§  UPDATE: advertises new path (or withdraws old) \n§  KEEPALIVE: keeps connection alive in absence of \nUPDATES; also ACKs OPEN request \n§  NOTIFICATION: reports errors in previous msg; also \nused to close connection \nPutting it Altogether: \nHow Does an Entry Get Into a \nRouter’s Forwarding Table? \nv  Answer is complicated! \nv  Ties together hierarchical routing (Section 4.5.3) \nwith BGP (4.6.3) and OSPF (4.6.2). \nv  Provides nice overview of BGP! \nrouting algorithms \nlocal forwarding table \noutput port \n138.16.64/22 \nHow does entry get in forwarding table? \nAssume prefix is \nin another AS. \nHigh-level overview \nRouter becomes aware of prefix \nRouter determines output port for prefix \nRouter enters prefix-port in forwarding table \nHow does entry get in forwarding table? \nRouter becomes aware of prefix \nv  BGP message contains “routes”  \nv  “route” is a prefix and attributes: AS-PATH, NEXT-HOP,\nv  Example: route: \nv  Prefix:138.16.64/22 ;  AS-PATH:  AS3  AS131 ;  \nNEXT-HOP:  201.44.13.125 \nRouter may receive multiple routes \nv  Router may receive multiple routes for same prefix \nv  Has to select one route \nv  Router selects route based on shortest AS-PATH \nSelect best BGP route to prefix \nv  Example: \nv  AS2 AS17  to 138.16.64/22  \nv  AS3 AS131 AS201 to 138.16.64/22  \nv  What if there is a tie? We’ll come back to that! \nFind best intra-route to BGP route \nv  Use selected route’s NEXT-HOP attribute  \n§  Route’s NEXT-HOP attribute is the IP address of the \nrouter interface that begins the AS PATH.  \nv  Example:  \nv  AS-PATH:  AS2  AS17 ;  NEXT-HOP: 111.99.86.55 \nv  Router uses OSPF to find shortest path from 1c to \n111.99.86.55 \n111.99.86.55 \nRouter identifies port for route \nv  Identifies port along the OSPF shortest path \nv  Adds prefix-port entry to its forwarding table: \n§  (138.16.64/22 , port 4)  \nHot Potato Routing \nv  Suppose there two or more best inter-routes. \nv  Then choose route with closest NEXT-HOP \n§  Use OSPF to determine which gateway is closest \n§  Q: From 1c, chose AS3 AS131 or AS2 AS17? \n§   A: route AS3 AS201 since it is closer  \nRouter becomes aware of prefix \nvia BGP route advertisements from other routers \nDetermine router output port for prefix \nUse BGP route selection to find best inter-AS route \nUse OSPF to find best intra-AS route  leading to best \ninter-AS route \nRouter identifies router port for that best route \nEnter prefix-port entry in forwarding table \nHow does entry get in forwarding table? \nNetwork Layer 4-132 \nBGP routing policy \nv  A,B,C are provider networks \nv  X,W,Y are customer (of provider networks) \nv  X is dual-homed: attached to two networks \n§  X does not want to route from B via X to C \n§  .. so X will not advertise to B a route to C \nNetwork Layer 4-133 \nBGP routing policy (2) \nv  A advertises path AW  to B \nv  B advertises path BAW to X  \nv  Should B advertise path BAW to C? \n§  No way! B gets no “revenue” for routing CBAW since neither W nor \nC are B’s customers  \n§  B wants to force C to route to w via A \n§  B wants to route only to/from its customers! \nNetwork Layer 4-134 \nWhy different Intra-, Inter-AS routing ?  \nv  inter-AS: admin wants control over how its traffic \nrouted, who routes through its net.  \nv  intra-AS: single admin, so no policy decisions needed \nv  hierarchical routing saves table size, reduced update \nperformance:  \nv  intra-AS: can focus on performance \nv  inter-AS: policy may dominate over performance \nNetwork Layer 4-135 \n4.1 introduction \n4.2 virtual circuit and \ndatagram networks \n4.3 what’s inside a router \n4.4 IP: Internet Protocol \n§  datagram format \n§  IPv4 addressing \n4.5 routing algorithms \n§  link state \n§  distance vector \n§  hierarchical routing \n4.6 routing in the Internet \n4.7 broadcast and multicast \nChapter 4: outline \nNetwork Layer 4-136 \nduplication \nduplication \ncreation/transmission \nBroadcast routing \nv  deliver packets from source to all other nodes \nv  source duplication is inefficient: \nv  source duplication: how does source determine \nrecipient addresses? \nNetwork Layer 4-137 \nIn-network duplication \nv  flooding: when node receives broadcast packet, \nsends copy to all neighbors \n§  problems: cycles & broadcast storm \nv  controlled flooding: node only broadcasts pkt if it \nhasn’t broadcast same packet before \n§  node keeps track of packet ids already broadacsted \n§  or reverse path forwarding (RPF): only forward packet \nif it arrived on shortest path between node and source \nv  spanning tree: \n§  no redundant packets received by any node \nNetwork Layer 4-138 \n(a) broadcast initiated at A \n(b) broadcast initiated at D \nSpanning tree \nv  first construct a spanning tree \nv  nodes then forward/make copies only along \nspanning tree \nNetwork Layer 4-139 \n(a) stepwise construction of \nspanning tree (center: E) \n(b) constructed spanning \nSpanning tree: creation \nv  center node \nv  each node sends unicast join message to center \n§  message forwarded until it arrives at a node already \nbelonging to spanning tree \nNetwork Layer 4-140 \nMulticast routing: problem statement \ngoal: find a tree (or trees) connecting routers having \nlocal mcast group members  \nv  tree: not all paths between routers used \nv  shared-tree: same tree used by all group members \nshared tree \nsource-based trees \nv  source-based: different tree from each sender to rcvrs \nNetwork Layer 4-141 \nApproaches for building mcast trees \napproaches: \nv  source-based tree: one tree per source \n§  shortest path trees \n§  reverse path forwarding \nv  group-shared tree: group uses one tree \n§  minimal spanning (Steiner)  \n§  center-based trees \n…we first look at basic approaches, then specific protocols \nadopting these approaches \nNetwork Layer 4-142 \nShortest path tree \nv  mcast forwarding tree: tree of shortest path \nroutes from source to all receivers \n§  Dijkstra’s algorithm \nrouter with attached \ngroup member \nrouter with no attached \ngroup member \nlink used for forwarding, \ni indicates order link \nadded by algorithm \nNetwork Layer 4-143 \nReverse path forwarding \nif (mcast datagram received on incoming link on \nshortest path back to center) \n   then flood datagram onto all outgoing links \n   else ignore datagram \nv  rely on router’s knowledge of unicast shortest \npath from it  to sender \nv  each router has simple forwarding behavior: \nNetwork Layer 4-144 \nReverse path forwarding: example \nv  result is a source-specific reverse SPT \n§  may be a bad choice with asymmetric links \nrouter with attached \ngroup member \nrouter with no attached \ngroup member \ndatagram will be  forwarded \ndatagram will not be  \nNetwork Layer 4-145 \nReverse path forwarding: pruning \nv  forwarding tree contains subtrees with no mcast group \n§  no need to forward datagrams down subtree \n§  “prune” msgs sent upstream by router with no \ndownstream group members \nrouter with attached \ngroup member \nrouter with no attached \ngroup member \nprune message \nlinks with multicast \nNetwork Layer 4-146 \nShared-tree: steiner tree \nv  steiner tree: minimum cost tree connecting all \nrouters with attached group members \nv  problem is NP-complete \nv  excellent heuristics exists \nv  not used in practice: \n§  computational complexity \n§  information about entire network needed \n§  monolithic: rerun whenever a router needs to join/\nNetwork Layer 4-147 \nCenter-based trees \nv  single delivery tree shared by all \nv  one router identified as “center” of tree \nv  to join: \n§  edge router sends unicast join-msg addressed to center \n§  join-msg “processed” by intermediate routers and \nforwarded towards center \n§  join-msg either hits existing tree branch for this center, \nor arrives at center \n§  path taken by join-msg becomes new branch of tree for \nthis router \nNetwork Layer 4-148 \nCenter-based trees: example \nsuppose R6 chosen as center: \nrouter with attached \ngroup member \nrouter with no attached \ngroup member \npath order in which join \nmessages generated \nNetwork Layer 4-149 \nInternet Multicasting Routing: DVMRP \nv  DVMRP: distance vector multicast routing \nprotocol, RFC1075 \nv  flood and prune:  reverse path forwarding, source-\n§  RPF tree based on DVMRP’s own routing tables \nconstructed by communicating DVMRP routers  \n§  no assumptions about underlying unicast \n§  initial datagram to mcast group flooded  everywhere \n§  routers not wanting group: send upstream prune msgs \nNetwork Layer 4-150 \nDVMRP: continued… \nv  soft state: DVMRP router periodically (1 min.) \n“forgets”  branches are pruned:  \n§  mcast data again flows down unpruned branch \n§  downstream router: reprune or else continue to receive \nv  routers can quickly regraft to tree  \n§  following IGMP join at leaf \nv  odds and ends \n§  commonly implemented in commercial router \nNetwork Layer 4-151 \nQ: how to connect “islands” of multicast  routers in a \n“sea” of unicast routers?  \nv  mcast datagram encapsulated inside “normal” (non-\nmulticast-addressed) datagram \nv  normal IP datagram sent thru “tunnel” via regular IP unicast \nto receiving mcast router (recall IPv6 inside IPv4 tunneling) \nv  receiving mcast router unencapsulates to get mcast \nphysical topology \nlogical topology \nNetwork Layer 4-152 \nPIM: Protocol Independent Multicast \nv  not dependent on any specific underlying unicast \nrouting algorithm (works with all) \nv  two different multicast distribution scenarios : \nv  group members densely \npacked, in “close” \nv  bandwidth more plentiful \nv  # networks with group \nmembers small wrt # \ninterconnected networks \nv  group members “widely \nv  bandwidth not plentiful \nNetwork Layer 4-153 \nConsequences of sparse-dense dichotomy:  \nv  group membership by \nrouters assumed until \nrouters explicitly prune \nv  data-driven construction on \nmcast tree (e.g., RPF) \nv  bandwidth and non-group-\nrouter processing profligate \nv  no membership until routers \nexplicitly join \nv  receiver- driven construction \nof mcast tree (e.g., center-\nv  bandwidth and non-group-\nrouter processing conservative \nNetwork Layer 4-154 \nPIM- dense mode \nflood-and-prune RPF: similar to DVMRP but… \nv  underlying unicast protocol provides RPF info \nfor incoming datagram \nv  less complicated (less efficient) downstream \nflood than DVMRP reduces reliance on \nunderlying routing algorithm \nv  has protocol mechanism for router to detect it \nis a leaf-node router \nNetwork Layer 4-155 \nPIM - sparse mode \nv  center-based approach \nv  router sends join msg to \nrendezvous point (RP) \n§  intermediate routers \nupdate state and \nforward join \nv  after joining via RP, router \ncan switch to source-\nspecific tree \n§  increased \nperformance: less \nconcentration, shorter \nall data multicast \nfrom rendezvous \nNetwork Layer 4-156 \nv  unicast data to RP, \nwhich distributes \ndown RP-rooted tree \nv  RP can extend mcast \ntree upstream to \nv  RP can send stop msg \nif no attached \n§  “no one is listening!” \nall data multicast \nfrom rendezvous \nPIM - sparse mode \nNetwork Layer 4-157 \n4.1 introduction \n4.2 virtual circuit and \ndatagram networks \n4.3 what’s inside a router \n4.4 IP: Internet Protocol \n§  datagram format, IPv4 \naddressing, ICMP, IPv6 \n4.5 routing algorithms \n§  link state, distance vector, \nhierarchical routing \n4.6 routing in the Internet \n§  RIP, OSPF, BGP \n4.7 broadcast and multicast \nChapter 4: done! \nv  understand principles behind network layer services: \n§  network layer service models, forwarding versus routing \nhow a router works, routing (path selection), broadcast, \nv  instantiation, implementation in the Internet",
    "unit": "Unit 1",
    "source_type": "notes",
    "book_priority": 0,
    "source_file": "Network Layer",
    "chunk_id": "Network Layer_chunk_0"
  },
  {
    "text": "Packet switching - Routing – Distance Vector and Link State Algorithms – RIP, OSPF and BGP - IPV4 \nPacket Format and Addressing – Effective IP address management techniques – Subnetting – CIDR – \nVLSM – DHCP – NAT – ICMP – Need for IPv6 – Addressing methods and types in IPv6 – IPv6 header – \nAdvantages of IPv6 – Transition from IPv4 to IPv6. \n1. NETWORK LAYER \n• The transport segment from the sending host is encapsulated into datagrams. \n• On the receiving side, the segments are delivered to the transport layer by the network layer \nprotocols in every host. \n• Routers examine header fields in all IP datagrams passing through them. \nForwarding: (Getting through a single interchange) packets from a router's input to the appropriate \nrouter output. \nRouting: (Planning a trip from source to destination) Determines the route taken by packets from source \nto destination. \nThe network layer is the third layer in the OSI model and plays a critical role in end-to-end \ncommunication by providing services such as: \n• Logical addressing: This includes assigning IP addresses to devices on a network to identify them \nuniquely and ensure proper packet delivery. \n• Routing: It involves determining the best path for data packets to travel from source to \ndestination across multiple networks (e.g., the internet). \n• Packet forwarding: This refers to the movement of packets across network devices (routers and \nswitches) based on the routing table and logical address. \n• Fragmentation and reassembly: This process breaks large packets into smaller fragments for \ntransmission over networks with different Maximum Transmission Unit (MTU) sizes, then \nreassembles them at the destination. \nPacket Switching \nDefinition: A method of breaking data into packets for transmission across networks, reassembled at \nthe destination. \n1. Datagram Switching: (Connectionless) Packets take different paths to the destination (e.g., IP \n• Advantages: Flexibility, fault tolerance, efficient use of network resources. \n• Disadvantages: Possibility of packet loss, out-of-order delivery, and delays due to congestion. \n2. Virtual Circuit Switching: (Connection-Oriented) A fixed path is established before transmission \n(e.g., MPLS – Multi Protocol Label Switching). \n• Advantages: More reliable, predictable performance. \n• Disadvantages: Less flexible, as the path must be predefined and maintained. \nVirtual Circuit Networks and Datagram Networks: \nVirtual Circuit Networks \nDatagram Networks \nConnection-oriented (path established \nbefore communication) \nConnectionless (no path established \nbeforehand) \nReliability \nMore reliable (due to fixed path and \nconnection) \nLess reliable (packets may be lost, \nduplicated, or unordered) \nFixed path for the entire communication \nIndependent routing for each packet \nPackets follow the same path and are \ndelivered in order \nPackets can take different paths and may \narrive out of order \nHandled by the network (dedicated path \nallows easy management) \nHandled by upper layers (e.g., transport \nRequires setup time to establish the \nNo setup time required for communication \nATM (Asynchronous Transfer Mode), \nFrame Relay, X.25 \nIP (Internet Protocol), UDP \nForwarding Table in Virtual Circuits (VC) and Datagram Networks \nVirtual Circuits (VC) \nForwarding Table: In a Virtual Circuit network, each router maintains a forwarding table that maps \nincoming VC numbers to outgoing VC numbers and interfaces. This table is essential for directing the \npackets along the pre-established path. \nExample Forwarding Table:  \nExplanation: \n• Incoming Interface: The interface where the \npacket arrives. \n• Incoming VC: The virtual circuit number of \nthe incoming packet. \n• Outgoing Interface: The interface where the \npacket should be forwarded. \n• Outgoing VC: The virtual circuit number \nassigned to the outgoing packet. \nDatagram Networks \nForwarding Table: In Datagram Networks, each router maintains a forwarding table that maps IP \naddress prefixes to outgoing interfaces. Each packet is routed independently based on the destination IP \nSignaling Protocols in Virtual Circuits (VC) and Datagram Networks \nRouting and Forwarding: \n• Routing is about selecting the best path to take across the network. \n• Forwarding is about sending a packet along that path based on the destination address. \nThe process of determining the best path \nfor packets to take. \nThe process of moving a packet from input to \noutput based on the destination. \nRouters use routing protocols and \nalgorithms to decide on paths. \nRouters or network devices forward packets \nusing forwarding tables. \nOccurs when a router learns the network \ntopology and updates routing tables. \nHappens continuously when a packet arrives \nat the router. \nInvolves choosing the overall route from \nsource to destination. \nInvolves deciding the next hop for a specific \nOSPF, BGP, RIP \nIP forwarding (in routers), MPLS forwarding \nFlowchart Structure – Routing \nGraph Extraction: \ngraph: G = (N,E) \nN = set of routers = { u, v, w, x, y, z } \nE = set of links ={ (u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), \n(w,z), (y,z) } \nc(x,x’) = cost of link (x,x’) \ne.g., c(w,z) = 5 \ncost could always be 1, or inversely related to bandwidth, or inversely related to congestion \ncost of path (x1, x2, x3,…, xp) = c(x1,x2) + c(x2,x3) + … + c(xp-1,xp) \nRouting algorithm classification \nBased on Path Calculation Method: \n(i) Static Routing Algorithms: \n• The paths are preconfigured by the network administrator and do not change unless manually \n• Example: Manual configuration of routes in a router. \n• Pros: Simple, predictable. \n• Cons: Not adaptive to network changes, requires manual intervention. \n(ii) Dynamic Routing Algorithms: \n• The paths are automatically determined and adjusted based on network topology changes and \ntraffic conditions. Routers exchange routing information to adapt to network changes. \n• Example: RIP, OSPF, BGP. \n• Pros: Adaptive to changes, can handle network failures and congestion. \n• Cons: More complex, requires more resources (e.g., processing power and memory). \nStatic Routing \nDynamic Routing \nConfiguration \nManually set by the admin. \nAutomatically updated by routers. \nAdaptability \nNo automatic updates. \nUpdates automatically with network \nScalability \nBest for small networks. \nBest for large networks. \nLow; no need for updates. \nHigher due to constant updates. \nFault Tolerance \nLimited; manual fixes needed. \nHigh; reroutes automatically. \nManual routes, Static IP routing. \nRIP, OSPF, EIGRP, BGP. \nSimple, low overhead. \nFlexible, adapts to changes. \nInflexible, hard to manage large \nMore complex, higher overhead. \nRouting protocols are vital for ensuring efficient data transmission across networks. This assignment \ndelves into three critical routing protocols: Routing Information Protocol (RIP), Open Shortest Path First \n(OSPF), and Border Gateway Protocol (BGP). While RIP and OSPF are primarily intra-domain protocols, \nBGP operates at the inter-domain level, managing routing across Autonomous Systems (AS). \n1. Routing Information Protocol (RIP) \nRIP, one of the earliest intra-AS routing protocols, is still utilized in smaller networks due to its simplicity. \nDefined in: \n• RIP Version 1: [RFC 1058] \n• RIP Version 2: [RFC 2453] (adds backward compatibility and route aggregation). \nIt is a distance-vector protocol based on hop count as the cost metric. \nKey Mechanisms \n1. Hop Count Metric \na. Each link has a cost of 1 hop. \nb. Maximum allowable cost: 15 hops, limiting RIP to smaller ASs. \n2. Routing Table \nEach router maintains a table with: \na. Destination subnet. \nb. Next hop router. \nc. Number of hops to destination. \n3. Routing Updates \na. Routers exchange distance vectors (RIP advertisements) every 30 seconds. \nb. Advertisements include up to 25 subnets. \n4. Failure Detection \na. No update within 180 seconds marks the neighbor unreachable. \n5. Implementation \na. Application-layer protocol using UDP on port 520. \nb. UNIX uses a routed process for routing updates. \nRIP Message Format \nThe message format is used to share information among different routers. The RIP contains the following \nfields in a message: \no Command: It is an 8-bit field that is used for request or reply. The value of the request is 1, and the \nvalue of the reply is 2. \no Version: Here, version means that which version of the protocol we are using. Suppose we are \nusing the protocol of version1, then we put the 1 in this field. \no Reserved: This is a reserved field, so it is filled with zeroes. \no Family: It is a 16-bit field. As we are using the TCP/IP family, so we put 2 value in this field. \no Network Address: It is defined as 14 bytes field. If we use the IPv4 version, then we use 4 bytes, \nand the other 10 bytes are all zeroes. \no Distance: The distance field specifies the hop count, i.e., the number of hops used to reach the \ndestination. \nHow does the RIP work? \nIf there are 8 routers in a network where Router 1 wants to send the data to Router 3. If the network is \nconfigured with RIP, it will choose the route which has the least number of hops. There are three routes in \nthe above network, i.e., Route 1, Route 2, and Route 3. The Route 2 contains the least number of hops, \ni.e., 2 where Route 1 contains 3 hops, and Route 3 contains 4 hops, so RIP will choose Route 2. \nAdvantages and Disadvantages \nDisadvantages \nSimplicity, easy setup \nLimited to 15-hop networks \nWidely supported \nSlow convergence (30-second updates) \nDecentralized operations \nVulnerable to count-to-infinity issue \nComparison with OSPF \n• Routing Type: RIP uses distance-vector; OSPF uses link-state. \n• Scalability: RIP is limited by 15 hops, while OSPF is more scalable. \n• Convergence: OSPF converges faster than RIP. \n2. Open Shortest Path First (OSPF) \nOSPF is a robust and scalable intra-AS link-state routing protocol designed to replace RIP. Defined in \nRFC 2328, it uses Dijkstra’s shortest-path algorithm. \nKey Mechanisms \n1. Link-State Flooding \na. Broadcasts link-state updates to all routers within an AS. \nb. Updates are triggered by topology changes or every 30 minutes. \n2. Routing Table Calculation \na. Builds a complete AS topology map. \nb. Shortest-path tree computed using Dijkstra's algorithm. \n3. Link Costs \na. Configurable by administrators to reflect hop count, bandwidth, etc. \n4. Integration with IP \na. OSPF uses IP protocol 89 and manages its own reliability and authentication. \nOSPF Message Format \nThe following are the fields in an OSPF message format: \no Version: It is an 8-bit field that specifies the OSPF protocol version. \no Type: It is an 8-bit field. It specifies the type of the OSPF packet. \no Message: It is a 16-bit field that defines the total length of the message, including the header. \nTherefore, the total length is equal to the sum of the length of the message and header. \no Source IP address: It defines the address from which the packets are sent. It is a sending routing \nIP address. \no Area identification: It defines the area within which the routing takes place. \no Checksum: It is used for error correction and error detection. \no Authentication type: There are two types of authentication, i.e., 0 and 1. Here, 0 means for none \nthat specifies no authentication is available and 1 means for pwd that specifies the password-\nbased authentication. \no Authentication: It is a 32-bit field that contains the actual value of the authentication data. \nAdvanced Features \n• Security: MD5-based authentication ensures message authenticity. \n• Multiple Same-Cost Paths: Enables load balancing. \n• Hierarchical Routing: Divides AS into areas connected by Area Border Routers (ABRs). \nAdvantages and Disadvantages \nDisadvantages \nEfficient convergence \nMore complex configuration \nSuitable for large networks \nHigher memory and CPU usage \nCustomizable link costs \n3. Border Gateway Protocol (BGP) \nBGP is an inter-domain routing protocol that manages routing between ASs. It is defined in RFC 4271 and \nensures efficient and policy-driven routing on the global Internet. \nKey Features \n1. Path Vector Protocol \na. Maintains the path information (AS Path) for each destination. \nb. Avoids routing loops by rejecting routes with its own AS in the path. \n2. Policy-Based Routing \na. Allows network operators to define routing policies based on business or technical \nrequirements. \n3. Message Types \na. OPEN: Establishes peer connections. \nb. UPDATE: Communicates route additions/removals. \nc. KEEPALIVE: Ensures session liveness. \nd. NOTIFICATION: Indicates errors or session termination. \n4. Scalability \na. Suitable for large-scale networks with thousands of ASs. \nb. Supports CIDR for efficient route aggregation. \nBGP Packet Format \nNow we will see the format in which the packet travels. The following are the fields in a BGP packet \n1. Marker: It is a 32-bit field which is used for the authentication purpose. \n2. Length: It is a 16-bit field that defines the total length of the message, including the header. \n3. Type: It is an 8-bit field that defines the type of the packe \nAdvantages and Disadvantages \nDisadvantages \nScalable for large networks \nConfiguration complexity \nPolicy-driven routing \nVulnerable to misconfigurations \nAvoids loops with AS Path \nBased on Routing Information Exchange: \n (i) Link-State Routing Algorithm: (GLOBAL): \n• Routers maintain a complete map of the network topology and use this information to calculate the \nbest path. Every router exchanges information about its directly connected links with all other \n• Example: OSPF (Open Shortest Path First), IS-IS (Intermediate System to Intermediate System). \n• Working: Routers send link-state advertisements (LSAs) to all other routers, which then use \nalgorithms (like Dijkstra's algorithm) to calculate the shortest paths. \n• Pros: Faster convergence, avoids routing loops. \n• Cons: Requires more resources (memory, CPU) for maintaining the topology map. \n Dijkstra's Algorithm \nDijkstra's algorithm is a fundamental algorithm used in link-state routing protocols like Open Shortest \nPath First (OSPF). It finds the shortest path from a source node to all other nodes in a weighted graph. \nSteps of Dijkstra's Algorithm \n1. Initialization: \na. Set the distance to the source node as 0. \nb. Set the distance to all other nodes as infinity (∞). \nc. Mark all nodes as unvisited. \n2. Select Node: \na. Pick the unvisited node with the smallest tentative distance (initially the source node). \n3. Update Neighbors: \na. For each unvisited neighbor of the current node: \ni. Calculate the tentative distance: Tentative Distance=Current Distance+Edge \nii. If the calculated distance is smaller than the known distance, update it. \n4. Mark Visited: \na. Once all neighbors are considered, mark the current node as visited. \na. Repeat steps 2–4 until all nodes are visited or the shortest path to the destination is found. \nNotation Used in Dijkstra's Algorithm \n• G(V,E): A graph with vertices V and edges E. \n• d[u]: The tentative distance from the source node s to node u. \n• w(u,v): The weight of the edge between nodes u and v. \n• : A priority queue (min-heap) of unvisited nodes, sorted by tentative distance. \nExample of Dijkstra's Algorithm \nGraph Details: \n• Nodes: A,B,C,D,E,F \n• Edges and Weights: \nInitial State: \nNode Distance from A \n1. Start at A: \na. Tentative distances: d[B]=4,d[C]=2. \nb. Mark A as visited. \n2. Move to C (smallest tentative distance): \na. Tentative distances: d[E]=5 (via C). \nb. Mark C as visited. \n3. Move to B: \na. Tentative distances: d[D]=14 (via B). \nb. Mark B as visited. \n4. Move to E: \na. Tentative distances: d[D]=9,d[F]=11. \nb. Mark E as visited. \n5. Move to D: \na. Tentative distances: d[F]=10 (via D). \nb. Mark D as visited. \n6. Move to F: \na. All nodes are visited. \nFinal Result: \nDistance from A \nDiscussion on Dijkstra's Algorithm \nAdvantages: \n1. Guaranteed Shortest Path: Always finds the shortest path in graphs with non-negative edge \n2. Efficient: Runs in O(V2) for dense graphs or O((V+E)logV) with a priority queue. \n3. Widely Used: Employed in real-world routing protocols like OSPF. \nLimitations: \n1. Non-Negative Weights Only: Does not work correctly with graphs containing negative weight \n2. Not Suitable for Frequent Updates: In networks with highly dynamic topology, repeated \nrecalculations can be computationally expensive. \nApplications: \n• Used in routing protocols (e.g., OSPF) to compute the shortest path. \n• Traffic engineering and navigation systems. \n• Network optimization and resource allocation. \n(ii) Distance-Vector Routing Algorithms (DECENTRALIZED): \n• Routers send updates about their routing tables to their neighbors periodically. The distance to a \ndestination is typically measured by the number of hops. \n• Example: RIP (Routing Information Protocol), BGP (Border Gateway Protocol) (in some modes). \n• Working: Routers exchange routing tables, and each router updates its table based on information \nfrom neighbors. They calculate the shortest path based on distance metrics (like hop count). \n• Pros: Simple to implement. \n• Cons: Slow to converge, prone to routing loops (especially in large networks). \nDistance vector algorithm \nBellman-Ford Algorithm \nclearly, dv(z) = 5, dx(z) = 3, dw(z) = 3B-F equation says: \ndu(z) = min { c(u,v) + dv(z), \nc(u,x) + dx(z), \nc(u,w) + dw(z) } \n= min {2 + 5,1 + 3, 5 + 3} = 4 \nnode achieving minimum is next \nhop in shortest path, used in forwarding table \nComparison Table \nLink State (LS) \nDistance Vector (DV) \n- Each node floods link-state packets \n(LSPs) to all other nodes.  \n- With n nodes and E links: O(nE) \nmessages are sent. \n- Only exchanges information with direct \n- Message complexity depends on \nconvergence time and varies with \nnetwork conditions. \nConvergence \n- Dijkstra’s algorithm runs in O(n2) time \n(or O(nlogn) with optimized \nimplementations).  \n- Requires O(nE) messages for global \ntopology updates.  \n- May exhibit oscillations under certain \nconditions. \n- Convergence time is variable and \ndepends on network size and changes.  \n- Susceptible to issues like routing loops \nand count-to-infinity problems, which \nslow down convergence. \n- A malfunctioning node can advertise \nincorrect link costs.  \n- Each node computes its own table \nindependently, so errors are localized. \n- A faulty node can advertise incorrect \npath costs.  \n- Errors can propagate through the \nnetwork as other nodes rely on shared \ndistance vectors. \n- Oscillations may occur during frequent \nupdates or rapid topology changes. \n- Vulnerable to routing loops, especially \nin the absence of mechanisms like split \nhorizon or poison reverse.  \n- Count-to-infinity problem leads to slow \nerror correction. \nPropagation \n- Errors remain localized since each \nnode computes its table based on its \nown topology knowledge. \n- Errors spread across the network \nbecause each node’s table is used by \nothers to compute paths.",
    "unit": "Unit 3",
    "source_type": "notes",
    "book_priority": 0,
    "source_file": "UNIT III NETWORK LAYER1",
    "chunk_id": "UNIT III NETWORK LAYER1_chunk_0"
  },
  {
    "text": "Packet switching - Routing – Distance Vector and Link State Algorithms – RIP, OSPF and \nBGP - IPV4 Packet Format and Addressing – Effective IP address management techniques – \nSubnetting – CIDR – VLSM – DHCP – NAT – ICMP – Need for IPv6 – Addressing methods and \ntypes in IPv6 – IPv6 header – Advantages of IPv6 – Transition from IPv4 to IPv6. \nIPv4 Datagram Header \nCharacteristics of IPv4 \n• IPv4 could be a 32-Bit IP Address. \n• IPv4 could be a numeric address, and its bits are separated by a dot. \n• The number of header fields is twelve and the length of the header \nfield is twenty. \n• It has Unicast, broadcast, and multicast style of addresses. \n• IPv4 supports VLSM (Virtual Length Subnet Mask). \n• IPv4 uses the Post Address Resolution Protocol to map to the MAC \n• RIP may be a routing protocol supported by the routed daemon. \n• Networks ought to be designed either manually or with DHCP. \n• Packet fragmentation permits from routers and causing host. \nIPv4 Datagram Header \n• VERSION: Version of the IP protocol (4 bits), which is 4 for IPv4  \n• HLEN: IP header length (4 bits), which is the number of 32 bit words \nin the header. The minimum value for this field is 5 and the \nmaximum is 15.  \n• Type of service: Low Delay, High Throughput, Reliability (8 bits)  \n• Total Length: Length of header + Data (16 bits), which has a \nminimum value 20 bytes and the maximum is 65,535 bytes.  \n• Identification: Unique Packet Id for identifying the group of \nfragments of a single IP datagram (16 bits)  \n• Flags: 3 flags of 1 bit each : reserved bit (must be zero), do not \nfragment flag, more fragments flag (same order)  \n• Fragment Offset: Represents the number of Data Bytes ahead of \nthe particular fragment in the particular Datagram. Specified in terms \nof number of 8 bytes, which has the maximum value of 65,528 \n• Time to live: Datagram’s lifetime (8 bits), It prevents the datagram \nto loop through the network by restricting the number of Hops taken \nby a Packet before delivering to the Destination. \n• Protocol: Name of the protocol to which the data is to be passed (8 \n• Header Checksum: 16 bits header checksum for checking errors in \nthe datagram header  \n• Source IP address: 32 bits IP address of the sender  \n• Destination IP address: 32 bits IP address of the receiver  \n• Option: Optional information such as source route, record route. \nUsed by the Network administrator to check whether a path is \nworking or not. \nThe IPv4 packet has a fixed header with a variable-length data section. Key fields in the \nDescription \nIPv4 (value = 4) \nHeader Length \nLength of the header in 32-bit words (min = 5, \nType of Service (TOS) \nPriority and quality of service options \nTotal Length \nTotal length of the packet (header + data) \nIdentification \nUnique identifier for fragmented packets \nControl fragmentation \nFragment Offset \nIndicates the fragment’s position in the \noriginal packet \nTime to Live (TTL) \nLimits the lifetime of the packet (hop count) \nIndicates the higher-layer protocol (e.g., TCP, \nHeader Checksum \nValidates the header’s integrity \nSource Address \nIP address of the sender \nDestination Address \nIP address of the receiver \nAdditional settings (rarely used) \nPayload containing upper-layer protocol \ninformation \nIPv6 Header \nSize (bits) \nDescription \nIPv6 (value = 6) \nTraffic Class \nSimilar to IPv4’s TOS; QoS priority. \nIdentifies packets requiring special \nPayload Length \nLength of the payload (data). \nNext Header \nIndicates the next protocol (e.g., TCP, \nSimilar to IPv4’s TTL; limits the number of \nSource Address \nIPv6 address of the sender. \nDestination \nIPv6 address of the receiver. \nNeed for IPv6 \nIPv4 has limitations that necessitated the development of IPv6: \nAddress Exhaustion: IPv4 provides ~4.3 billion addresses, which is insufficient for \nthe growing number of devices. \nNetwork Growth: IPv6 supports a virtually unlimited number of devices. \nImproved Security: IPv6 integrates IPsec for secure communication. \nBetter QoS: IPv6 offers improved Quality of Service (QoS) for real-time applications. \nSimplified Configuration: IPv6 includes autoconfiguration capabilities, reducing \nadministrative overhead. \nAddressing Methods and Types in IPv6: \nDescription \nIdentifies a single interface; packets are delivered to one specific \nIdentifies multiple interfaces; packets are delivered to all members \nof a group. \nIdentifies multiple interfaces; packets are delivered to the nearest \none in terms of routing distance. \nAddress Type \nDescription \nGlobal Unicast \nUnique addresses routable over the internet. \nFE80::/10 Automatically configured addresses for communication \nwithin a link; not routable beyond the link. \nUnique Local \nFor local communications; not routable over the internet \nbut unique within an organization. \nUsed for multicast groups; packets are delivered to \nmultiple destinations. \nUnspecified \nRepresents no address (used as a placeholder). \nUsed by a device to send packets to itself (loopback \nReserved for special purposes, including future use and \ntesting (e.g., FF02::1 for all nodes). \nAdvantages of IPv6 \nLarger Address Space: IPv6 provides 21282^{128}2128 addresses, far more than \nIPv4's 2322^{32}232. \nSimplified Header: Improves processing efficiency by routers. \nImproved Security: Built-in IPsec support for authentication and encryption. \nAutoconfiguration: Supports stateful (DHCPv6) and stateless (SLAAC) \nconfiguration. \nBetter Support for Mobile Devices: Allows seamless mobility with minimal \ndisruption. \nEliminates NAT: Direct addressing removes the need for Network Address \nTranslation. \nTransition from IPv4 to IPv6 \nChallenges in Transition \nIPv4 and IPv6 are not directly compatible. \nRequires dual-stack operation and gradual migration. \nTechniques for Transition \n1. Dual-Stack: Devices run both IPv4 and IPv6 simultaneously. \n2. Tunneling: IPv6 packets are encapsulated within IPv4 packets for transport over an \nIPv4 network. \no Examples: 6to4, Teredo, and ISATAP. \n3. Translation: Converts IPv4 packets to IPv6 and vice versa using NAT64/DNS64. \nEffective IP Address Management Techniques: \n1. Subnetting \na. Definition: Dividing a large IP network into smaller, manageable sub-\nnetworks (subnets). \nb. Purpose: Optimizes IP address usage, improves network performance, and \nenhances security. \nc. Example: Splitting 192.168.1.0/24 into two subnets: 192.168.1.0/25 \nand 192.168.1.128/25. \n2. CIDR (Classless Inter-Domain Routing) \na. Definition: A method to allocate IP addresses efficiently by allowing flexible \nprefix lengths, replacing the rigid class-based addressing. \nb. Purpose: Reduces wasted IP addresses and simplifies routing. \nc. Example: Instead of a classful network 192.168.1.0/24, CIDR can allocate \nsmaller networks like 192.168.1.0/28 for 16 addresses. \n3. VLSM (Variable Length Subnet Masking) \na. Definition: Extends subnetting by allowing different subnets to have varying \nsizes within the same network. \nb. Purpose: Maximizes efficient IP address allocation based on the number of \nrequired hosts. \nc. Example: A 192.168.1.0/24 network can be divided as 192.168.1.0/26 \nfor 64 hosts and 192.168.1.64/27 for 32 hosts. \n4. DHCP (Dynamic Host Configuration Protocol) \na. Definition: Automatically assigns IP addresses and other network \nconfigurations to devices. \nb. Purpose: Simplifies IP management in dynamic or large networks. \nc. Example: Assigns IP addresses from a pool (192.168.1.100 to \n192.168.1.200) to devices when they connect. \n5. NAT (Network Address Translation) \na. Definition: Allows multiple devices on a private network to access the \nInternet using a single public IP address. \nb. Purpose: Conserves public IPs, enhances security, and provides IP address \nc. Example: A private network (192.168.1.0/24) is translated to a single \npublic IP (203.0.113.1) for external communication. \n6. ICMP (Internet Control Message Protocol) \na. Definition: Used for diagnostic and error-reporting purposes in network \ncommunication. \nb. Purpose: Helps identify issues like unreachable hosts or network errors. \nc. Example: Ping uses ICMP to check the availability and response time of a \nDefinition: \nSubnetting is the process of dividing a larger IP network into smaller, more manageable \nsub-networks (subnets). Each subnet operates as an independent network while still being \npart of the original larger network. \n• Efficient IP Address Utilization: Allocates IP addresses based on specific needs \n(e.g., number of devices per subnet). \n• Improved Network Performance: Reduces broadcast traffic within each subnet. \n• Enhanced Security: Isolates sensitive parts of a network. \n• Simplified Management: Organizes networks logically. \nKey Concepts \n1. Subnet Mask: \na. Defines the division between the network and host portions of an IP address. \nb. Example: 255.255.255.0 (or /24) indicates the first 24 bits represent the \n2. CIDR Notation: \na. Specifies the subnet mask using a / followed by the number of network bits. \nb. Example: 192.168.1.0/25. \n3. Subnet ID and Broadcast Address: \na. Each subnet has a unique ID and broadcast address. \nb. Example: For 192.168.1.0/25, the subnet ID is 192.168.1.0, and the \nbroadcast address is 192.168.1.127. \nSubnetting Example \n• Given: Network 192.168.1.0/24. \n• Task: Create four subnets. \n• Solution: Increase subnet mask from /24 to /26 (adds 2 bits to the network \no Subnet Mask: 255.255.255.192 or /26. \no Each subnet has 2^6 = 64 addresses (62 usable for hosts). \nBroadcast Address \n192.168.1.0/26 \n192.168.1.1 \n192.168.1.62 \n192.168.1.63 \n192.168.1.64/26 \n192.168.1.65 \n192.168.1.126 \n192.168.1.127 \n192.168.1.128/26 192.168.1.129 \n192.168.1.190 \n192.168.1.191 \n192.168.1.192/26 192.168.1.193 \n192.168.1.254 \n192.168.1.255 \nBenefits of Subnetting: \n1. Conserves IP Addresses: Reduces wastage in larger networks. \n2. Limits Broadcast Domains: Ensures less traffic and better performance. \n3. Logical Organization: Facilitates departmental or geographical segregation. \nSupernetting \nDefinition: \nSupernetting is the process of combining multiple smaller, contiguous networks (subnets) \ninto a single larger network (supernet). It is the inverse of subnetting and is typically used in \nrouting to reduce the size of routing tables. \n• Simplifies routing by aggregating multiple routes into a single entry. \n• Optimizes the allocation of IP addresses. \n• Reduces the load on routers and improves efficiency in large networks \nKey Features: \n1. Combines Networks: Merges multiple networks with contiguous IP address \n2. Flexible Masking: Uses a shorter subnet mask to include more addresses in a \nsingle block. \n3. Classless: Like CIDR, supernetting ignores traditional class boundaries (Class A, B, \nSuppose you have four Class C networks: \n• 192.168.1.0/24 \n• 192.168.2.0/24 \n• 192.168.3.0/24 \n• 192.168.4.0/24 \nTo supernet these, a shorter prefix /22 can represent them as a single block: \n• Supernet: 192.168.0.0/22 \n• Address Range: 192.168.0.0 to 192.168.3.255. \n1. Reduces routing table size by advertising one route instead of four. \n2. Simplifies network management. \n3. Minimizes overhead in routers. \nApplications: \n• Used by ISPs for route aggregation to advertise fewer routes. \n• Optimizes large-scale enterprise networks with contiguous IP address blocks. \n1. CIDR (Classless Inter-Domain Routing) \n• Definition: A method for allocating IP addresses and routing by allowing flexible \nsubnet masks instead of fixed class-based masks (Class A, B, C). \n• Purpose: Optimizes IP address allocation and reduces routing table size. \n• Key Features: \no Uses prefix length to define networks (e.g., 192.168.1.0/24 for 256 \naddresses). \no Aggregates routes to minimize entries (e.g., 192.168.0.0/16 combines \nmultiple /24 subnets). \nInstead of allocating a full Class B network (172.16.0.0/16), CIDR allows creating a \nsmaller network, such as 172.16.0.0/20 for 4,096 addresses. \n1. Write the subnet mask in decimal notation. Example: 255.255.255.0. \n2. Convert the decimal subnet mask into binary. \no 255.255.255.0 becomes 11111111.11111111.11111111.00000000. \n3. Count the number of 1 bits in the binary subnet mask. \no Here, there are 24 ones. \n4. The CIDR notation is the number of 1s. \no For the example 255.255.255.0, the CIDR is /24. \n1. Subnet Mask: 255.255.255.128 \no Binary: 11111111.11111111.11111111.10000000 \no Number of 1s: 25 \no CIDR: /25 \n2. Subnet Mask: 255.255.252.0 \no Binary: 11111111.11111111.11111100.00000000 \no Number of 1s: 22 \no CIDR: /22 \nSteps to Convert CIDR to Subnet Mask \n1. Identify the CIDR Prefix \nThe number after the / in CIDR represents the number of 1s in the subnet mask. For \nexample, /20 means the subnet mask has 20 1s. \n2. Write the Binary Subnet Mask \nWrite 1s for the prefix length and fill the rest with 0s to make a total of 32 bits. \nExample for /20: 11111111.11111111.11110000.00000000. \n3. Convert Each Octet from Binary to Decimal \nBreak the 32-bit binary string into four 8-bit segments (octets) and convert each to \nExample: 11111111.11111111.11110000.00000000 → 255.255.240.0. \nExample Conversions \nCIDR Binary Subnet Mask \nDecimal Subnet Mask \n11111111.11111111.00000000.00000000 255.255.0.0 \n11111111.11111111.11111111.00000000 255.255.255.0 \n11111111.11111111.11111111.11100000 255.255.255.224 \n11111111.11111111.11111111.11111100 255.255.255.252 \n2. VLSM (Variable Length Subnet Masking) \n• Definition: Extends subnetting by allowing subnets of different sizes within the \nsame network. \n• Purpose: Efficiently uses IP addresses by matching the subnet size to the number \nof required hosts. \n• Key Features: \no Avoids IP wastage by creating subnets based on host requirements. \no Compatible with CIDR. \nFrom 192.168.1.0/24: \no /26 for 64 hosts (e.g., 192.168.1.0/26). \no /27 for 32 hosts (e.g., 192.168.1.64/27). \no /30 for point-to-point links (e.g., 192.168.1.96/30). \n3. DHCP (Dynamic Host Configuration Protocol) \n• Definition: A protocol that dynamically assigns IP addresses and other network \nsettings to devices. \n• Purpose: Simplifies IP management in networks with frequently changing devices. \n• Key Features: \no Centralized IP allocation. \no Prevents conflicts by ensuring unique IPs. \no Can also configure DNS, default gateway, and subnet masks. \n• Example Workflow: \no A device sends a DHCP Discover message. \no The DHCP server replies with a DHCP Offer. \no The device accepts using a DHCP Request. \no The server confirms with a DHCP Acknowledgement. \n4. NAT (Network Address Translation) \n• Definition: A technique where private IP addresses are translated to a public IP \naddress for external communication. \n• Purpose: Conserves public IP addresses and enhances security. \n• Key Features: \no Static NAT: Maps a private IP to a specific public IP. \no Dynamic NAT: Maps private IPs to a pool of public IPs. \no PAT (Port Address Translation): Multiple private IPs share a single public IP \nusing unique ports. \no Internal Network: 192.168.0.0/24. \no External IP: 203.0.113.1. \no Devices with private IPs access the internet using 203.0.113.1. \n5. ICMP (Internet Control Message Protocol) \n• Definition: A protocol used for diagnostic and error-reporting in IP networks. \n• Purpose: Helps identify network issues such as unreachable hosts or congestion. \n• Key Features: \no Works alongside IP but does not transfer data. \no Generates error messages (e.g., \"Destination Unreachable\"). \no Used by tools like ping and traceroute. \n• Example Uses: \no Ping: Sends ICMP Echo Request to check if a host is reachable. \no Traceroute: Uses ICMP to map the path packets take to a destinatio",
    "unit": "Unit 3",
    "source_type": "notes",
    "book_priority": 0,
    "source_file": "UNIT III NETWORK LAYER2",
    "chunk_id": "UNIT III NETWORK LAYER2_chunk_0"
  }
]